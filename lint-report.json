[{"filePath":"D:\\prj\\p2p_conference\\code\\electron.vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\electron\\credentials.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":116,"column":18,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":116,"endColumn":35,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\electron\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\electron\\main.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":16,"column":7,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":16,"endColumn":43,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\electron\\preload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\App.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleToggleMute'. Either include it or remove the dependency array.","line":230,"column":6,"nodeType":"ArrayExpression","endLine":230,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [handleToggleMute, showToast, t]","fix":{"range":[7407,7421],"text":"[handleToggleMute, showToast, t]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'handleCancelSearch' and 'handleToggleMute'. Either include them or remove the dependency array.","line":332,"column":6,"nodeType":"ArrayExpression","endLine":332,"endColumn":46,"suggestions":[{"desc":"Update the dependencies array to be: [appView, connectionState, handleCancelSearch, handleToggleMute, showToast, t]","fix":{"range":[10931,10971],"text":"[appView, connectionState, handleCancelSearch, handleToggleMute, showToast, t]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\audio-processor\\AudioPipeline.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":397,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":397,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":407,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":407,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":416,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":416,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":424,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":424,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AudioPipeline\r\n * \r\n * Manages the complete audio processing chain including:\r\n * - Audio context management (48kHz for RNNoise compatibility)\r\n * - WASM module loading and transfer to AudioWorklet\r\n * - RNNoise noise suppression\r\n * - Gain control and visualization\r\n * \r\n * Architecture:\r\n * Microphone 鈫?[Browser AEC/AGC] 鈫?AudioContext 鈫?RNNoise AudioWorklet 鈫?WebRTC\r\n */\r\n\r\nimport { AudioLog } from '../utils/Logger';\r\n\r\n// WASM file path (relative to index.html - works with both dev server and file:// protocol)\r\nconst RNNOISE_WASM_PATH = './audio-processor/rnnoise.wasm';\r\nconst PROCESSOR_PATH = './audio-processor/noise-processor.js';\r\n\r\nexport class AudioPipeline {\r\n  private audioContext: AudioContext | null = null;\r\n  private sourceNode: MediaStreamAudioSourceNode | null = null;\r\n  private destinationNode: MediaStreamAudioDestinationNode | null = null;\r\n  private workletNode: AudioWorkletNode | null = null;\r\n  private gainNode: GainNode | null = null;\r\n  private analyserNode: AnalyserNode | null = null;\r\n\r\n  // WASM module storage\r\n  private wasmModule: WebAssembly.Module | null = null;\r\n  private wasmMemory: WebAssembly.Memory | null = null;\r\n\r\n  // State\r\n  private isInitialized: boolean = false;\r\n  private isWasmReady: boolean = false;\r\n  private noiseSuppressionEnabled: boolean = true;\r\n\r\n  /**\r\n   * Initialize the audio pipeline\r\n   */\r\n  async initialize(): Promise<void> {\r\n    if (this.isInitialized) {\r\n      AudioLog.debug('Already initialized');\r\n      return;\r\n    }\r\n\r\n    AudioLog.info('Initializing AudioPipeline...');\r\n\r\n    try {\r\n      // Create audio context at 48kHz (required by RNNoise)\r\n      this.audioContext = new AudioContext({\r\n        sampleRate: 48000,\r\n        latencyHint: 'interactive'\r\n      });\r\n\r\n      AudioLog.info('AudioContext created', { sampleRate: this.audioContext.sampleRate });\r\n\r\n      if (this.audioContext.sampleRate !== 48000) {\r\n        AudioLog.warn('Sample rate is not 48kHz! RNNoise may not work correctly.', { \r\n          actualRate: this.audioContext.sampleRate \r\n        });\r\n      }\r\n\r\n      // Load WASM module first\r\n      await this.loadWasmModule();\r\n\r\n      // Load AudioWorklet processor\r\n      try {\r\n        AudioLog.debug('Loading AudioWorklet module...', { path: PROCESSOR_PATH });\r\n        await this.audioContext.audioWorklet.addModule(PROCESSOR_PATH);\r\n        AudioLog.info('AudioWorklet module loaded successfully');\r\n      } catch (workletError) {\r\n        AudioLog.warn('Failed to load AudioWorklet - noise suppression will be unavailable', { \r\n          error: workletError \r\n        });\r\n      }\r\n\r\n      // Create destination node for WebRTC output\r\n      this.destinationNode = this.audioContext.createMediaStreamDestination();\r\n\r\n      // Create gain node for volume control\r\n      this.gainNode = this.audioContext.createGain();\r\n      this.gainNode.gain.value = 1.0;\r\n\r\n      // Create analyser for visualization\r\n      this.analyserNode = this.audioContext.createAnalyser();\r\n      this.analyserNode.fftSize = 256;\r\n      this.analyserNode.smoothingTimeConstant = 0.8;\r\n\r\n      this.isInitialized = true;\r\n      AudioLog.info('AudioPipeline initialization complete', { \r\n        wasmReady: this.isWasmReady,\r\n        sampleRate: this.audioContext.sampleRate\r\n      });\r\n\r\n    } catch (err) {\r\n      AudioLog.error('AudioPipeline initialization failed', { error: err });\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load the RNNoise WASM module\r\n   */\r\n  private async loadWasmModule(): Promise<void> {\r\n    try {\r\n      AudioLog.info('Loading RNNoise WASM module...', { path: RNNOISE_WASM_PATH });\r\n\r\n      // Fetch the WASM binary\r\n      const response = await fetch(RNNOISE_WASM_PATH);\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to fetch WASM: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const wasmBinary = await response.arrayBuffer();\r\n      AudioLog.info('WASM binary loaded', { size: wasmBinary.byteLength });\r\n\r\n      // Create shared memory for WASM\r\n      // RNNoise needs at least 256 pages (16MB) for its internal allocations\r\n      this.wasmMemory = new WebAssembly.Memory({\r\n        initial: 256,  // 16MB initial\r\n        maximum: 512,  // 32MB max\r\n        shared: false  // Shared memory requires special headers, keep false for compatibility\r\n      });\r\n\r\n      // Compile the WASM module\r\n      this.wasmModule = await WebAssembly.compile(wasmBinary);\r\n      AudioLog.info('WASM module compiled successfully');\r\n\r\n      this.isWasmReady = true;\r\n\r\n    } catch (error) {\r\n      AudioLog.error('Failed to load WASM module', { error });\r\n      this.isWasmReady = false;\r\n      // Don't throw - allow fallback to bypass mode\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connect an input stream through the processing pipeline\r\n   * @returns Processed MediaStream for WebRTC\r\n   */\r\n  async connectInputStream(inputStream: MediaStream): Promise<MediaStream> {\r\n    if (!this.audioContext || !this.destinationNode || !this.gainNode) {\r\n      throw new Error('AudioPipeline not initialized');\r\n    }\r\n\r\n    // Disconnect any existing connections\r\n    this.disconnect();\r\n\r\n    // Resume audio context if suspended (browser autoplay policy)\r\n    if (this.audioContext.state === 'suspended') {\r\n      await this.audioContext.resume();\r\n      AudioLog.info('AudioContext resumed from suspended state');\r\n    }\r\n\r\n    // Create source from input stream\r\n    this.sourceNode = this.audioContext.createMediaStreamSource(inputStream);\r\n\r\n    // Determine if we should use noise suppression\r\n    const useNoiseSuppression =\r\n      this.noiseSuppressionEnabled &&\r\n      this.isWasmReady &&\r\n      this.wasmModule &&\r\n      this.wasmMemory &&\r\n      this.audioContext.audioWorklet;\r\n\r\n    AudioLog.debug('Noise suppression decision', {\r\n      enabled: this.noiseSuppressionEnabled,\r\n      wasmReady: this.isWasmReady,\r\n      willUse: useNoiseSuppression\r\n    });\r\n\r\n    if (useNoiseSuppression) {\r\n      try {\r\n        // Create noise suppression worklet node\r\n        this.workletNode = new AudioWorkletNode(this.audioContext, 'noise-suppressor', {\r\n          numberOfInputs: 1,\r\n          numberOfOutputs: 1,\r\n          channelCount: 1,\r\n          channelCountMode: 'explicit',\r\n          processorOptions: {\r\n            sampleRate: this.audioContext.sampleRate\r\n          }\r\n        });\r\n\r\n        // Set up message handler for worklet communication\r\n        this.workletNode.port.onmessage = this.handleWorkletMessage.bind(this);\r\n\r\n        // Initialize WASM in the worklet\r\n        await this.initializeWorkletWasm();\r\n\r\n        // Connect: source 鈫?worklet 鈫?gain 鈫?analyser 鈫?destination\r\n        this.sourceNode.connect(this.workletNode);\r\n        this.workletNode.connect(this.gainNode);\r\n        this.gainNode.connect(this.analyserNode!);\r\n        this.analyserNode!.connect(this.destinationNode);\r\n\r\n        AudioLog.info('Connected with RNNoise AI noise suppression');\r\n\r\n      } catch (err) {\r\n        AudioLog.warn('Failed to enable noise suppression, falling back to bypass', { error: err });\r\n        this.connectBypass();\r\n      }\r\n    } else {\r\n      this.connectBypass();\r\n    }\r\n\r\n    return this.destinationNode.stream;\r\n  }\r\n\r\n  /**\r\n   * Connect in bypass mode (no noise suppression)\r\n   */\r\n  private connectBypass(): void {\r\n    if (!this.sourceNode || !this.gainNode || !this.analyserNode || !this.destinationNode) {\r\n      return;\r\n    }\r\n\r\n    // Direct connection: source 鈫?gain 鈫?analyser 鈫?destination\r\n    this.sourceNode.connect(this.gainNode);\r\n    this.gainNode.connect(this.analyserNode);\r\n    this.analyserNode.connect(this.destinationNode);\r\n\r\n    AudioLog.info('Connected in bypass mode (no AI noise suppression)', {\r\n      wasmReady: this.isWasmReady,\r\n      nsEnabled: this.noiseSuppressionEnabled\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initialize WASM in the AudioWorklet\r\n   */\r\n  private async initializeWorkletWasm(): Promise<void> {\r\n    if (!this.workletNode || !this.wasmModule || !this.wasmMemory) {\r\n      throw new Error('Worklet or WASM not ready');\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => {\r\n        reject(new Error('WASM initialization timeout'));\r\n      }, 5000);\r\n\r\n      // Listen for ready/error messages\r\n      const originalHandler = this.workletNode!.port.onmessage;\r\n      this.workletNode!.port.onmessage = (event) => {\r\n        if (event.data.type === 'ready') {\r\n          clearTimeout(timeout);\r\n          this.workletNode!.port.onmessage = originalHandler;\r\n          AudioLog.info('Worklet WASM initialized successfully');\r\n          resolve();\r\n        } else if (event.data.type === 'error') {\r\n          clearTimeout(timeout);\r\n          this.workletNode!.port.onmessage = originalHandler;\r\n          AudioLog.error('Worklet WASM initialization failed', { error: event.data.error });\r\n          reject(new Error(event.data.error));\r\n        }\r\n\r\n        // Also call original handler\r\n        if (originalHandler) {\r\n          originalHandler.call(this.workletNode!.port, event);\r\n        }\r\n      };\r\n\r\n      // Send WASM module to worklet\r\n      AudioLog.debug('Sending WASM module to worklet...');\r\n      this.workletNode!.port.postMessage({\r\n        type: 'init',\r\n        data: {\r\n          wasmModule: this.wasmModule,\r\n          wasmMemory: this.wasmMemory\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle messages from the AudioWorklet\r\n   */\r\n  private handleWorkletMessage(event: MessageEvent): void {\r\n    const { type, data } = event.data;\r\n\r\n    switch (type) {\r\n      case 'ready':\r\n        AudioLog.debug('Worklet reports ready');\r\n        break;\r\n\r\n      case 'error':\r\n        AudioLog.error('Worklet error', { data });\r\n        break;\r\n\r\n      case 'stats':\r\n        AudioLog.debug('Worklet stats', { data });\r\n        break;\r\n\r\n      default:\r\n        // Unknown message type\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get audio level for visualization (0-100)\r\n   */\r\n  getAudioLevel(): number {\r\n    if (!this.analyserNode) return 0;\r\n\r\n    const dataArray = new Uint8Array(this.analyserNode.frequencyBinCount);\r\n    this.analyserNode.getByteFrequencyData(dataArray);\r\n\r\n    // Calculate RMS-like average\r\n    const average = dataArray.reduce((sum, val) => sum + val, 0) / dataArray.length;\r\n\r\n    // Scale to 0-100 with some compression for better visual feedback\r\n    return Math.min(100, Math.pow(average / 128, 0.7) * 100);\r\n  }\r\n\r\n  /**\r\n   * Set noise suppression enabled/disabled\r\n   */\r\n  setNoiseSuppression(enabled: boolean): void {\r\n    this.noiseSuppressionEnabled = enabled;\r\n\r\n    if (this.workletNode) {\r\n      this.workletNode.port.postMessage({\r\n        type: 'setEnabled',\r\n        data: { enabled }\r\n      });\r\n      AudioLog.info('Noise suppression toggled', { enabled });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if RNNoise AI noise suppression is active\r\n   */\r\n  isNoiseSuppressionActive(): boolean {\r\n    return this.isWasmReady && this.noiseSuppressionEnabled && this.workletNode !== null;\r\n  }\r\n\r\n  /**\r\n   * Get noise suppression status\r\n   */\r\n  getNoiseSuppressionStatus(): { enabled: boolean; active: boolean; wasmReady: boolean } {\r\n    return {\r\n      enabled: this.noiseSuppressionEnabled,\r\n      active: this.isNoiseSuppressionActive(),\r\n      wasmReady: this.isWasmReady\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Request performance statistics from the worklet\r\n   */\r\n  async getStats(): Promise<any> {\r\n    if (!this.workletNode) {\r\n      return { error: 'Worklet not available' };\r\n    }\r\n\r\n    // Store reference to avoid null check issues in closure\r\n    const workletNode = this.workletNode;\r\n\r\n    return new Promise((resolve) => {\r\n      const timeout = setTimeout(() => {\r\n        resolve({ error: 'Stats request timeout' });\r\n      }, 1000);\r\n\r\n      const handler = (event: MessageEvent) => {\r\n        if (event.data.type === 'stats') {\r\n          clearTimeout(timeout);\r\n          workletNode.port.removeEventListener('message', handler);\r\n          resolve(event.data.data);\r\n        }\r\n      };\r\n\r\n      workletNode.port.addEventListener('message', handler);\r\n      workletNode.port.postMessage({ type: 'getStats' });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set output gain (volume)\r\n   */\r\n  setGain(value: number): void {\r\n    if (this.gainNode) {\r\n      // Clamp value between 0 and 2 (200%)\r\n      this.gainNode.gain.value = Math.max(0, Math.min(2, value));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect audio nodes\r\n   */\r\n  disconnect(): void {\r\n    if (this.sourceNode) {\r\n      try {\r\n        this.sourceNode.disconnect();\r\n      } catch (e) {\r\n        // Ignore disconnect errors\r\n      }\r\n      this.sourceNode = null;\r\n    }\r\n\r\n    if (this.workletNode) {\r\n      try {\r\n        this.workletNode.disconnect();\r\n        this.workletNode.port.postMessage({ type: 'destroy' });\r\n      } catch (e) {\r\n        // Ignore disconnect errors\r\n      }\r\n      this.workletNode = null;\r\n    }\r\n\r\n    if (this.gainNode) {\r\n      try {\r\n        this.gainNode.disconnect();\r\n      } catch (e) {\r\n        // Ignore disconnect errors\r\n      }\r\n    }\r\n\r\n    if (this.analyserNode) {\r\n      try {\r\n        this.analyserNode.disconnect();\r\n      } catch (e) {\r\n        // Ignore disconnect errors\r\n      }\r\n    }\r\n\r\n    AudioLog.debug('Pipeline disconnected');\r\n  }\r\n\r\n  /**\r\n   * Cleanup and destroy the pipeline\r\n   */\r\n  async destroy(): Promise<void> {\r\n    this.disconnect();\r\n\r\n    if (this.audioContext) {\r\n      try {\r\n        await this.audioContext.close();\r\n      } catch (e) {\r\n        AudioLog.warn('Error closing AudioContext', { error: e });\r\n      }\r\n      this.audioContext = null;\r\n    }\r\n\r\n    this.destinationNode = null;\r\n    this.gainNode = null;\r\n    this.analyserNode = null;\r\n    this.wasmModule = null;\r\n    this.wasmMemory = null;\r\n    this.isInitialized = false;\r\n    this.isWasmReady = false;\r\n\r\n    AudioLog.info('AudioPipeline destroyed');\r\n  }\r\n\r\n  /**\r\n   * Get processed output stream\r\n   */\r\n  getOutputStream(): MediaStream | null {\r\n    return this.destinationNode?.stream || null;\r\n  }\r\n\r\n  /**\r\n   * Get audio context sample rate\r\n   */\r\n  getSampleRate(): number {\r\n    return this.audioContext?.sampleRate || 48000;\r\n  }\r\n\r\n  /**\r\n   * Check if pipeline is initialized\r\n   */\r\n  isReady(): boolean {\r\n    return this.isInitialized;\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nlet pipelineInstance: AudioPipeline | null = null;\r\n\r\nexport function getAudioPipeline(): AudioPipeline {\r\n  if (!pipelineInstance) {\r\n    pipelineInstance = new AudioPipeline();\r\n  }\r\n  return pipelineInstance;\r\n}\r\n\r\n/**\r\n * Reset the singleton instance (useful for testing)\r\n */\r\nexport async function resetAudioPipeline(): Promise<void> {\r\n  if (pipelineInstance) {\r\n    await pipelineInstance.destroy();\r\n    pipelineInstance = null;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\audio-processor\\RingBuffer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\audio-processor\\SoundManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\AudioMeter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\ConnectionOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\DeviceSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\ErrorBanner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\LeaveConfirmDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\LobbyView.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'startMicTest' and 'testingMic'. Either include them or remove the dependency array.","line":91,"column":6,"nodeType":"ArrayExpression","endLine":91,"endColumn":27,"suggestions":[{"desc":"Update the dependencies array to be: [selectedInputDevice, startMicTest, testingMic]","fix":{"range":[2711,2732],"text":"[selectedInputDevice, startMicTest, testingMic]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * LobbyView Component\r\n * Initial screen for entering room ID and configuring audio before joining\r\n */\r\n\r\nimport React, { useState, useEffect, useRef } from 'react'\r\nimport { DeviceSelector } from './DeviceSelector'\r\nimport { AudioMeter } from './AudioMeter'\r\nimport { useI18n } from '../hooks/useI18n'\r\nimport { UILog } from '../utils/Logger'\r\nimport type { AudioDevice } from '@/types'\r\n\r\ninterface LobbyViewProps {\r\n  onJoinRoom: (roomId: string, userName: string) => void\r\n  inputDevices: AudioDevice[]\r\n  outputDevices: AudioDevice[]\r\n  selectedInputDevice: string | null\r\n  selectedOutputDevice: string | null\r\n  onInputDeviceChange: (deviceId: string) => void\r\n  onOutputDeviceChange: (deviceId: string) => void\r\n  onRefreshDevices: () => void\r\n  audioLevel: number\r\n  isLoading: boolean\r\n  onOpenSettings: () => void\r\n}\r\n\r\n/**\r\n * Generate a random room ID with sufficient entropy\r\n */\r\nfunction generateRoomId(): string {\r\n  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789'\r\n  let result = ''\r\n  const array = new Uint32Array(12)\r\n  crypto.getRandomValues(array)\r\n  for (let i = 0; i < 12; i++) {\r\n    result += chars[array[i] % chars.length]\r\n  }\r\n  return result\r\n}\r\n\r\nexport const LobbyView: React.FC<LobbyViewProps> = ({\r\n  onJoinRoom,\r\n  inputDevices,\r\n  outputDevices,\r\n  selectedInputDevice,\r\n  selectedOutputDevice,\r\n  onInputDeviceChange,\r\n  onOutputDeviceChange,\r\n  onRefreshDevices,\r\n  audioLevel: _audioLevel,\r\n  isLoading,\r\n  onOpenSettings\r\n}) => {\r\n  const { t } = useI18n()\r\n  const [roomId, setRoomId] = useState('')\r\n  const [userName, setUserName] = useState('')\r\n  const [testingMic, setTestingMic] = useState(false)\r\n  const [testAudioLevel, setTestAudioLevel] = useState(0)\r\n  const [showPrivacyNotice, setShowPrivacyNotice] = useState(false)\r\n  const [isJoining, setIsJoining] = useState(false)  // Immediate loading state\r\n  \r\n  // Refs for audio testing\r\n  const testStreamRef = useRef<MediaStream | null>(null)\r\n  const audioContextRef = useRef<AudioContext | null>(null)\r\n  const analyserRef = useRef<AnalyserNode | null>(null)\r\n  const animationFrameRef = useRef<number | null>(null)\r\n\r\n  // Generate default username\r\n  useEffect(() => {\r\n    const storedName = localStorage.getItem('p2p-conf-username')\r\n    if (storedName) {\r\n      setUserName(storedName)\r\n    } else {\r\n      setUserName(`User-${Math.random().toString(36).slice(2, 7)}`)\r\n    }\r\n  }, [])\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      stopMicTest()\r\n    }\r\n  }, [])\r\n\r\n  // Stop mic test when device changes, then restart\r\n  useEffect(() => {\r\n    if (testingMic && selectedInputDevice) {\r\n      stopMicTest()\r\n      startMicTest()\r\n    }\r\n  }, [selectedInputDevice])\r\n\r\n  /**\r\n   * Start microphone test with audio level monitoring\r\n   */\r\n  const startMicTest = async () => {\r\n    UILog.info('Starting microphone test')\r\n    \r\n    try {\r\n      const constraints: MediaStreamConstraints = {\r\n        audio: selectedInputDevice \r\n          ? { deviceId: { exact: selectedInputDevice } }\r\n          : true,\r\n        video: false\r\n      }\r\n      \r\n      const stream = await navigator.mediaDevices.getUserMedia(constraints)\r\n      testStreamRef.current = stream\r\n      \r\n      onRefreshDevices()\r\n      \r\n      const audioContext = new AudioContext()\r\n      audioContextRef.current = audioContext\r\n      \r\n      const analyser = audioContext.createAnalyser()\r\n      analyser.fftSize = 256\r\n      analyserRef.current = analyser\r\n      \r\n      const source = audioContext.createMediaStreamSource(stream)\r\n      source.connect(analyser)\r\n      \r\n      const dataArray = new Uint8Array(analyser.frequencyBinCount)\r\n      \r\n      const updateLevel = () => {\r\n        if (!analyserRef.current) return\r\n        \r\n        analyserRef.current.getByteFrequencyData(dataArray)\r\n        \r\n        const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length\r\n        const normalizedLevel = Math.min(100, (average / 128) * 100)\r\n        \r\n        setTestAudioLevel(normalizedLevel)\r\n        animationFrameRef.current = requestAnimationFrame(updateLevel)\r\n      }\r\n      \r\n      updateLevel()\r\n      setTestingMic(true)\r\n      \r\n      UILog.info('Microphone test started successfully')\r\n    } catch (err) {\r\n      UILog.error('Microphone test failed', { error: err })\r\n      alert(t('lobby.micPermissionDenied'))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop microphone test\r\n   */\r\n  const stopMicTest = () => {\r\n    if (animationFrameRef.current) {\r\n      cancelAnimationFrame(animationFrameRef.current)\r\n      animationFrameRef.current = null\r\n    }\r\n    \r\n    if (audioContextRef.current) {\r\n      audioContextRef.current.close()\r\n      audioContextRef.current = null\r\n    }\r\n    analyserRef.current = null\r\n    \r\n    if (testStreamRef.current) {\r\n      testStreamRef.current.getTracks().forEach(track => track.stop())\r\n      testStreamRef.current = null\r\n    }\r\n    \r\n    setTestAudioLevel(0)\r\n    setTestingMic(false)\r\n    \r\n    UILog.debug('Microphone test stopped')\r\n  }\r\n\r\n  const handleUserNameChange = (name: string) => {\r\n    setUserName(name)\r\n    localStorage.setItem('p2p-conf-username', name)\r\n  }\r\n\r\n  const handleGenerateRoom = () => {\r\n    const newRoomId = generateRoomId()\r\n    setRoomId(newRoomId)\r\n    UILog.debug('Generated room ID', { roomId: newRoomId })\r\n  }\r\n\r\n  const handleJoin = async () => {\r\n    if (roomId.trim().length < 4) {\r\n      alert(t('lobby.roomIdMinLength'))\r\n      return\r\n    }\r\n    if (userName.trim().length < 2) {\r\n      alert(t('lobby.nameMinLength'))\r\n      return\r\n    }\r\n    \r\n    setIsJoining(true)\r\n    UILog.info('Joining room', { roomId: roomId.trim(), userName: userName.trim() })\r\n    \r\n    // Stop mic test FIRST and wait for release\r\n    stopMicTest()\r\n    \r\n    // Give the audio system time to fully release the mic\r\n    // This prevents race condition on Linux where getUserMedia hangs\r\n    await new Promise(resolve => setTimeout(resolve, 100))\r\n    \r\n    onJoinRoom(roomId.trim(), userName.trim())\r\n  }\r\n\r\n  const handleTestMic = () => {\r\n    if (testingMic) {\r\n      stopMicTest()\r\n    } else {\r\n      startMicTest()\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex-1 flex items-center justify-center p-8\">\r\n      <div className=\"card max-w-md w-full p-8 animate-fade-in\">\r\n        {/* Header */}\r\n        <div className=\"text-center mb-8\">\r\n          <div className=\"inline-flex items-center justify-center w-16 h-16 bg-blue-100 rounded-full mb-4\">\r\n            <svg className=\"w-8 h-8 text-blue-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} \r\n                d=\"M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z\" />\r\n            </svg>\r\n          </div>\r\n          <h1 className=\"text-2xl font-bold text-gray-900\">{t('app.name')}</h1>\r\n          <p className=\"text-sm text-gray-500 mt-1\">{t('app.tagline')}</p>\r\n        </div>\r\n\r\n        {/* Form */}\r\n        <div className=\"space-y-6\">\r\n          {/* User Name */}\r\n          <div>\r\n            <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n              {t('lobby.yourName')}\r\n            </label>\r\n            <input\r\n              type=\"text\"\r\n              value={userName}\r\n              onChange={(e) => handleUserNameChange(e.target.value)}\r\n              placeholder={t('lobby.enterName')}\r\n              className=\"input\"\r\n              maxLength={32}\r\n            />\r\n          </div>\r\n\r\n          {/* Room ID */}\r\n          <div>\r\n            <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n              {t('lobby.roomId')}\r\n            </label>\r\n            <div className=\"flex gap-2\">\r\n              <input\r\n                type=\"text\"\r\n                value={roomId}\r\n                onChange={(e) => setRoomId(e.target.value)}\r\n                placeholder={t('lobby.enterRoomId')}\r\n                className=\"input flex-1\"\r\n                maxLength={32}\r\n              />\r\n              <button\r\n                onClick={handleGenerateRoom}\r\n                className=\"btn btn-secondary whitespace-nowrap\"\r\n                title={t('lobby.generate')}\r\n              >\r\n                {t('lobby.generate')}\r\n              </button>\r\n            </div>\r\n            <p className=\"text-xs text-gray-500 mt-1\">\r\n              {t('lobby.shareRoomId')}\r\n            </p>\r\n            {roomId.length > 0 && roomId.length < 8 && (\r\n              <p className=\"text-xs text-yellow-600 mt-1 flex items-center gap-1\">\r\n                <svg className=\"w-3 h-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\" />\r\n                </svg>\r\n                {t('lobby.roomIdSecurityWarning')}\r\n              </p>\r\n            )}\r\n          </div>\r\n\r\n          {/* Audio Devices */}\r\n          <div className=\"space-y-4\">\r\n            <div className=\"flex items-center justify-between\">\r\n              <span className=\"text-sm font-medium text-gray-700\">{t('lobby.audioSetup')}</span>\r\n              <button\r\n                onClick={handleTestMic}\r\n                className={`text-sm ${testingMic ? 'text-red-600 hover:text-red-700' : 'text-blue-600 hover:text-blue-700'} font-medium`}\r\n              >\r\n                {testingMic ? `鈻?${t('lobby.stopTest')}` : `鈻?${t('lobby.testMicrophone')}`}\r\n              </button>\r\n            </div>\r\n\r\n            <DeviceSelector\r\n              label={t('lobby.microphone')}\r\n              devices={inputDevices}\r\n              selectedDeviceId={selectedInputDevice}\r\n              onSelect={onInputDeviceChange}\r\n              icon=\"mic\"\r\n            />\r\n\r\n            {testingMic && (\r\n              <div className=\"bg-gray-50 rounded-lg p-3 border border-gray-200\">\r\n                <div className=\"flex items-center justify-between mb-2\">\r\n                  <span className=\"text-xs text-gray-500\">{t('lobby.inputLevel')}</span>\r\n                  <span className=\"text-xs font-mono text-gray-600\">{Math.round(testAudioLevel)}%</span>\r\n                </div>\r\n                <AudioMeter level={testAudioLevel} />\r\n                <p className=\"text-xs text-green-600 mt-2\">\r\n                  鉁?{t('lobby.micWorking')}\r\n                </p>\r\n              </div>\r\n            )}\r\n\r\n            <DeviceSelector\r\n              label={t('lobby.speaker')}\r\n              devices={outputDevices}\r\n              selectedDeviceId={selectedOutputDevice}\r\n              onSelect={onOutputDeviceChange}\r\n              icon=\"speaker\"\r\n            />\r\n          </div>\r\n\r\n          {/* Privacy Notice */}\r\n          <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-3\">\r\n            <div \r\n              className=\"flex items-start gap-2 cursor-pointer\"\r\n              onClick={() => setShowPrivacyNotice(!showPrivacyNotice)}\r\n            >\r\n              <svg className=\"w-5 h-5 text-yellow-600 flex-shrink-0 mt-0.5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} \r\n                  d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\" />\r\n              </svg>\r\n              <div className=\"flex-1\">\r\n                <p className=\"text-sm text-yellow-800 font-medium\">{t('lobby.privacyNotice')}</p>\r\n                {showPrivacyNotice && (\r\n                  <p className=\"text-xs text-yellow-700 mt-1\">\r\n                    {t('lobby.privacyText')}\r\n                  </p>\r\n                )}\r\n              </div>\r\n              <svg \r\n                className={`w-4 h-4 text-yellow-600 transform transition-transform ${showPrivacyNotice ? 'rotate-180' : ''}`} \r\n                fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"\r\n              >\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\r\n              </svg>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Join Button */}\r\n          <button\r\n            onClick={handleJoin}\r\n            disabled={isLoading || isJoining || roomId.length < 4}\r\n            className=\"btn btn-primary w-full py-3 text-lg disabled:opacity-50 disabled:cursor-not-allowed\"\r\n          >\r\n            {(isLoading || isJoining) ? (\r\n              <span className=\"flex items-center justify-center gap-2\">\r\n                <svg className=\"animate-spin h-5 w-5\" viewBox=\"0 0 24 24\">\r\n                  <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" fill=\"none\" />\r\n                  <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z\" />\r\n                </svg>\r\n                {t('lobby.joining')}\r\n              </span>\r\n            ) : (\r\n              t('lobby.joinRoom')\r\n            )}\r\n          </button>\r\n        </div>\r\n\r\n        {/* Footer */}\r\n        <div className=\"mt-6 pt-4 border-t border-gray-100 flex justify-between items-center\">\r\n          <span className=\"text-xs text-gray-400\">\r\n            {t('app.name')} {t('app.version')}\r\n          </span>\r\n          <button\r\n            onClick={onOpenSettings}\r\n            className=\"text-xs text-gray-500 hover:text-gray-700 flex items-center gap-1\"\r\n          >\r\n            <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} \r\n                d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z\" />\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\r\n            </svg>\r\n            {t('lobby.settings')}\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\ParticipantCard.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'localSpeakerMuted', 'peerId', and 'volume'. Either include them or remove the dependency array.","line":151,"column":6,"nodeType":"ArrayExpression","endLine":151,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [stream, isLocal, peerId, localSpeakerMuted, volume]","fix":{"range":[4930,4947],"text":"[stream, isLocal, peerId, localSpeakerMuted, volume]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ParticipantCard Component\r\n * Displays a single participant in the conference room\r\n */\r\n\r\nimport React, { useRef, useEffect, useState } from 'react'\r\nimport { AudioMeter } from './AudioMeter'\r\nimport { useI18n } from '../hooks/useI18n'\r\nimport { AudioLog } from '../utils/Logger'\r\n\r\ninterface ParticipantCardProps {\r\n  name: string\r\n  peerId: string\r\n  isMicMuted: boolean\r\n  isSpeakerMuted: boolean\r\n  isLocal: boolean\r\n  audioLevel: number\r\n  connectionState: RTCPeerConnectionState | 'connected'\r\n  stream?: MediaStream\r\n  outputDeviceId?: string | null\r\n  localSpeakerMuted?: boolean  // Whether local user has muted their speaker\r\n  volume?: number  // Per-participant volume (0-150, 100 = normal)\r\n  onVolumeChange?: (volume: number) => void  // Callback for volume change\r\n  platform?: 'win' | 'mac' | 'linux'\r\n}\r\n\r\nexport const ParticipantCard: React.FC<ParticipantCardProps> = ({\r\n  name,\r\n  peerId,\r\n  isMicMuted,\r\n  isSpeakerMuted,\r\n  isLocal,\r\n  audioLevel,\r\n  connectionState,\r\n  stream,\r\n  outputDeviceId,\r\n  localSpeakerMuted = false,\r\n  volume = 100,\r\n  onVolumeChange,\r\n  platform\r\n}) => {\r\n  const { t } = useI18n()\r\n  const audioRef = useRef<HTMLAudioElement>(null)\r\n  const [remoteAudioLevel, setRemoteAudioLevel] = useState(0)\r\n  const analyserRef = useRef<AnalyserNode | null>(null)\r\n  const audioContextRef = useRef<AudioContext | null>(null)\r\n  const animationRef = useRef<number | null>(null)\r\n  const gainNodeRef = useRef<GainNode | null>(null)\r\n  const [showVolumeSlider, setShowVolumeSlider] = useState(false)\r\n\r\n  // Set up audio playback for remote streams\r\n  useEffect(() => {\r\n    if (!stream || isLocal) return\r\n\r\n    const audioElement = audioRef.current\r\n    if (!audioElement) return\r\n\r\n    AudioLog.debug('Setting up audio playback', {\r\n      peerId,\r\n      streamId: stream.id,\r\n      trackCount: stream.getTracks().length,\r\n      audioTracks: stream.getAudioTracks().length\r\n    })\r\n\r\n    // Verify stream has audio tracks\r\n    const audioTracks = stream.getAudioTracks()\r\n    if (audioTracks.length === 0) {\r\n      AudioLog.error('Stream has no audio tracks!', { peerId, streamId: stream.id })\r\n      return\r\n    }\r\n\r\n    // Log track state\r\n    audioTracks.forEach((track, idx) => {\r\n      AudioLog.debug(`Audio track ${idx}`, {\r\n        id: track.id,\r\n        enabled: track.enabled,\r\n        muted: track.muted,\r\n        readyState: track.readyState\r\n      })\r\n    })\r\n\r\n    audioElement.srcObject = stream\r\n\r\n    // Mute audio element if local speaker is muted\r\n    audioElement.muted = localSpeakerMuted\r\n\r\n    // Try to play with retry mechanism\r\n    const playAudio = async () => {\r\n      try {\r\n        await audioElement.play()\r\n        AudioLog.info('Audio playback started successfully', { peerId })\r\n      } catch (err: any) {\r\n        AudioLog.warn('Autoplay blocked, will retry on user interaction', { error: err.message })\r\n\r\n        // Set up a one-time click handler to retry playback\r\n        const handleUserInteraction = () => {\r\n          audioElement.play()\r\n            .then(() => AudioLog.info('Audio playback started after user interaction', { peerId }))\r\n            .catch(e => AudioLog.error('Still failed to play after interaction', e))\r\n          document.removeEventListener('click', handleUserInteraction)\r\n          document.removeEventListener('keydown', handleUserInteraction)\r\n        }\r\n\r\n        document.addEventListener('click', handleUserInteraction, { once: true })\r\n        document.addEventListener('keydown', handleUserInteraction, { once: true })\r\n      }\r\n    }\r\n\r\n    playAudio()\r\n\r\n    // Set up audio level monitoring\r\n    if (!audioContextRef.current) {\r\n      audioContextRef.current = new AudioContext()\r\n    }\r\n\r\n    const ctx = audioContextRef.current\r\n    const analyser = ctx.createAnalyser()\r\n    analyser.fftSize = 256\r\n    analyserRef.current = analyser\r\n\r\n    // Create gain node for per-participant volume control\r\n    const gainNode = ctx.createGain()\r\n    gainNode.gain.value = volume / 100\r\n    gainNodeRef.current = gainNode\r\n\r\n    const source = ctx.createMediaStreamSource(stream)\r\n    source.connect(analyser)\r\n    // Note: We use the audio element for playback, gain is controlled via element.volume\r\n    // The gainNode here is for future AudioContext-based playback if needed\r\n\r\n    const dataArray = new Uint8Array(analyser.frequencyBinCount)\r\n\r\n    const updateLevel = () => {\r\n      analyser.getByteFrequencyData(dataArray)\r\n      const avg = dataArray.reduce((a, b) => a + b, 0) / dataArray.length\r\n      setRemoteAudioLevel(Math.min(100, (avg / 128) * 100))\r\n      animationRef.current = requestAnimationFrame(updateLevel)\r\n    }\r\n\r\n    updateLevel()\r\n\r\n    return () => {\r\n      if (animationRef.current) {\r\n        cancelAnimationFrame(animationRef.current)\r\n      }\r\n      if (gainNodeRef.current) {\r\n        gainNodeRef.current.disconnect()\r\n        gainNodeRef.current = null\r\n      }\r\n    }\r\n  }, [stream, isLocal])\r\n\r\n  // Update audio element volume when volume prop changes\r\n  useEffect(() => {\r\n    const audioElement = audioRef.current\r\n    if (audioElement && !isLocal) {\r\n      // HTML audio element volume is 0-1, but we allow up to 150% (1.5)\r\n      audioElement.volume = Math.min(1, volume / 100)\r\n      // For volumes > 100%, we'd need Web Audio API gain node\r\n      // For now, cap at 100% on element level\r\n    }\r\n  }, [volume, isLocal])\r\n\r\n  // Update muted state when localSpeakerMuted changes\r\n  useEffect(() => {\r\n    const audioElement = audioRef.current\r\n    if (audioElement && !isLocal) {\r\n      audioElement.muted = localSpeakerMuted\r\n    }\r\n  }, [localSpeakerMuted, isLocal])\r\n\r\n  // Set output device for remote audio\r\n  useEffect(() => {\r\n    const audioElement = audioRef.current\r\n    if (!audioElement || !outputDeviceId || isLocal) return\r\n\r\n    if ('setSinkId' in audioElement) {\r\n      (audioElement as any).setSinkId(outputDeviceId).catch((err: Error) => {\r\n        AudioLog.warn('Failed to set output device', err)\r\n      })\r\n    }\r\n  }, [outputDeviceId, isLocal])\r\n\r\n  // Get connection status color\r\n  const getStatusColor = (): string => {\r\n    switch (connectionState) {\r\n      case 'connected':\r\n        return 'bg-green-500'\r\n      case 'connecting':\r\n        return 'bg-yellow-500'\r\n      case 'disconnected':\r\n      case 'failed':\r\n        return 'bg-red-500'\r\n      default:\r\n        return 'bg-gray-400'\r\n    }\r\n  }\r\n\r\n  // Generate avatar initials\r\n  const getInitials = (name: string): string => {\r\n    return name\r\n      .split(' ')\r\n      .map(n => n[0])\r\n      .join('')\r\n      .toUpperCase()\r\n      .slice(0, 2)\r\n  }\r\n\r\n  // Generate avatar color based on peer ID\r\n  const getAvatarColor = (id: string): string => {\r\n    const colors = [\r\n      'bg-blue-500',\r\n      'bg-green-500',\r\n      'bg-purple-500',\r\n      'bg-pink-500',\r\n      'bg-indigo-500',\r\n      'bg-teal-500',\r\n      'bg-orange-500',\r\n      'bg-cyan-500'\r\n    ]\r\n    const hash = id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)\r\n    return colors[hash % colors.length]\r\n  }\r\n\r\n  const displayLevel = isLocal ? audioLevel : remoteAudioLevel\r\n  const showMicIndicator = isMicMuted\r\n  const showSpeakerIndicator = isSpeakerMuted\r\n\r\n  return (\r\n    <div className={`\r\n      card p-4 flex flex-col items-center gap-3 transition-all\r\n      ${displayLevel > 10 && !isMicMuted ? 'ring-2 ring-green-400 ring-opacity-50' : ''}\r\n    `}>\r\n      {/* Hidden audio element for remote streams */}\r\n      {!isLocal && <audio ref={audioRef} autoPlay playsInline />}\r\n\r\n      {/* Avatar */}\r\n      <div className=\"relative\">\r\n        <div className={`\r\n          w-16 h-16 rounded-full flex items-center justify-center text-white text-xl font-bold\r\n          ${isLocal ? 'bg-blue-600' : getAvatarColor(peerId)}\r\n          ${displayLevel > 10 && !isMicMuted ? 'animate-pulse-ring' : ''}\r\n        `}>\r\n          {getInitials(name)}\r\n        </div>\r\n\r\n        {/* Mic mute indicator (bottom-right) */}\r\n        {showMicIndicator && (\r\n          <div\r\n            className=\"absolute -bottom-1 -right-1 w-6 h-6 bg-red-500 rounded-full flex items-center justify-center\"\r\n            title={t('room.micMuted')}\r\n          >\r\n            <svg className=\"w-3 h-3 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2}\r\n                d=\"M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z\" />\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 3l18 18\" />\r\n            </svg>\r\n          </div>\r\n        )}\r\n\r\n        {/* Speaker mute indicator (bottom-left) */}\r\n        {showSpeakerIndicator && (\r\n          <div\r\n            className=\"absolute -bottom-1 -left-1 w-6 h-6 bg-orange-500 rounded-full flex items-center justify-center\"\r\n            title={t('room.speakerMuted')}\r\n          >\r\n            <svg className=\"w-3 h-3 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2}\r\n                d=\"M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z\" />\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2}\r\n                d=\"M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2\" />\r\n            </svg>\r\n          </div>\r\n        )}\r\n\r\n        {/* Connection status dot */}\r\n        <div className={`absolute top-0 right-0 w-3 h-3 rounded-full border-2 border-white ${getStatusColor()}`} />\r\n      </div>\r\n\r\n      {/* Name and Platform */}\r\n      <div className=\"text-center\">\r\n        <div className=\"flex items-center justify-center gap-1\">\r\n          {platform && (\r\n            <span className=\"text-gray-400\" title={platform === 'win' ? 'Windows' : platform === 'mac' ? 'macOS' : 'Linux'}>\r\n              {platform === 'win' && (\r\n                <svg className=\"w-3.5 h-3.5\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\r\n                  <path d=\"M0 3.449L9.75 2.1v9.451H0m10.949-9.602L24 0v11.4H10.949M0 12.6h9.75v9.451L0 20.699M10.949 12.6H24V24l-12.9-1.801\" />\r\n                </svg>\r\n              )}\r\n              {platform === 'mac' && (\r\n                <svg className=\"w-3.5 h-3.5\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\r\n                  <path d=\"M18.71 19.5c-.83 1.24-1.71 2.45-3.05 2.47-1.34.03-1.77-.79-3.29-.79-1.53 0-2 .77-3.27.82-1.31.05-2.3-1.32-3.14-2.53C4.25 17 2.94 12.45 4.7 9.39c.87-1.52 2.43-2.48 4.12-2.51 1.28-.02 2.5.87 3.29.87.78 0 2.26-1.07 3.81-.91.65.03 2.47.26 3.64 1.98-.09.06-2.17 1.28-2.15 3.81.03 3.02 2.65 4.03 2.68 4.04-.03.07-.42 1.44-1.38 2.83M13 3.5c.73-.83 1.94-1.46 2.94-1.5.13 1.17-.34 2.35-1.04 3.19-.69.85-1.83 1.51-2.95 1.42-.15-1.15.41-2.35 1.05-3.11z\" />\r\n                </svg>\r\n              )}\r\n              {platform === 'linux' && (\r\n                <svg className=\"w-3.5 h-3.5\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\r\n                  <path d=\"M12.504 0c-.155 0-.315.008-.48.021-4.226.333-3.105 4.807-3.17 6.298-.076 1.092-.3 1.953-1.05 3.02-.885 1.051-2.127 2.75-2.716 4.521-.278.832-.41 1.684-.287 2.489a.424.424 0 00-.11.135c-.26.268-.45.6-.663.839-.199.199-.485.267-.797.4-.313.136-.658.269-.864.68-.09.189-.136.394-.132.602 0 .199.027.4.055.536.058.399.116.728.04.97-.249.68-.28 1.145-.106 1.484.174.334.535.47.94.601.81.2 1.91.135 2.774.6.926.466 1.866.67 2.616.47.526-.116.97-.464 1.208-.946.587.26 1.35.352 2.14.352.79 0 1.553-.092 2.14-.352.237.482.68.83 1.208.946.75.2 1.69-.004 2.616-.47.865-.465 1.964-.4 2.774-.6.406-.13.766-.267.94-.6.175-.34.143-.804-.105-1.485-.076-.242-.018-.571.039-.97.028-.135.055-.337.055-.536a1.08 1.08 0 00-.132-.602c-.205-.41-.551-.544-.864-.68-.312-.133-.598-.2-.797-.4a3.36 3.36 0 01-.664-.839.443.443 0 00-.109-.135c.123-.805-.009-1.657-.287-2.49-.589-1.77-1.83-3.469-2.716-4.52-.75-1.067-.974-1.928-1.05-3.021-.065-1.49 1.056-5.965-3.17-6.298-.165-.013-.325-.021-.48-.021z\" />\r\n                </svg>\r\n              )}\r\n            </span>\r\n          )}\r\n          <p className=\"font-medium text-gray-900 text-sm truncate max-w-[120px]\">\r\n            {name}\r\n          </p>\r\n        </div>\r\n        {!isLocal && connectionState !== 'connected' && (\r\n          <p className=\"text-xs text-gray-500 capitalize\">\r\n            {connectionState}\r\n          </p>\r\n        )}\r\n      </div>\r\n\r\n      {/* Audio Level Meter */}\r\n      <div className=\"w-full\">\r\n        <AudioMeter level={isMicMuted ? 0 : displayLevel} size=\"sm\" />\r\n      </div>\r\n\r\n      {/* Per-participant Volume Control (for remote participants only) */}\r\n      {!isLocal && onVolumeChange && (\r\n        <div className=\"w-full mt-2\">\r\n          <button\r\n            onClick={() => setShowVolumeSlider(!showVolumeSlider)}\r\n            className=\"text-xs text-gray-500 hover:text-gray-700 flex items-center gap-1 w-full justify-center\"\r\n          >\r\n            <svg className=\"w-3 h-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2}\r\n                d=\"M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z\" />\r\n            </svg>\r\n            {volume}%\r\n          </button>\r\n          {showVolumeSlider && (\r\n            <div className=\"mt-2 px-2 animate-fade-in\">\r\n              <input\r\n                type=\"range\"\r\n                min=\"0\"\r\n                max=\"100\"\r\n                value={volume}\r\n                onChange={(e) => onVolumeChange(parseInt(e.target.value))}\r\n                className=\"w-full h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600\"\r\n              />\r\n              <div className=\"flex justify-between text-xs text-gray-400 mt-1\">\r\n                <span>0%</span>\r\n                <span>100%</span>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n    </div>\r\n  )\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\RoomView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\SettingsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\Toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\components\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\hooks\\useI18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\hooks\\useMediaStream.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'stopCapture'. Either include it or remove the dependency array.","line":380,"column":6,"nodeType":"ArrayExpression","endLine":380,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [stopCapture]","fix":{"range":[12719,12721],"text":"[stopCapture]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\hooks\\usePeerConnections.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\hooks\\useRoom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\signaling\\SimplePeerManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'remainingLength' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":630,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":630,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":1253,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":1253,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SimplePeerManager - Browser-compatible WebRTC P2P implementation\r\n * Uses MQTT over WebSocket with proper keepalive and trickle ICE\r\n * \r\n * MULTI-BROKER STRATEGY: To maximize connectivity, we connect to ALL available\r\n * MQTT brokers simultaneously and broadcast messages on all of them. This ensures\r\n * that even if a user can only reach some brokers (due to network issues), they\r\n * can still communicate with others who share at least one common broker.\r\n * \r\n * IMPORTANT NOTES ON SIGNALING CHANNELS:\r\n * 1. MQTT (Multi-broker) - Primary signaling for remote peer discovery\r\n *    - Messages are broadcast to all connected brokers\r\n *    - Deduplication prevents processing same message multiple times\r\n *    - Automatic reconnection with exponential backoff\r\n * \r\n * 2. BroadcastChannel - Secondary channel for same-device testing ONLY\r\n *    - ONLY works within the same browser on the same machine (same origin)\r\n *    - CANNOT replace MQTT for remote communication\r\n *    - Useful for development/testing without network\r\n */\r\n\r\nimport { SignalingLog, PeerLog } from '../utils/Logger'\r\nimport type { ConnectionQuality } from '@/types'\r\n\r\n// Generate a random peer ID\r\nexport const generatePeerId = (): string => {\r\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\r\n  let result = ''\r\n  for (let i = 0; i < 16; i++) {\r\n    result += chars.charAt(Math.floor(Math.random() * chars.length))\r\n  }\r\n  return result\r\n}\r\n\r\n// Self ID for this client\r\nexport const selfId = generatePeerId()\r\n\r\n// ============================================\r\n// Credentials loaded from main process via IPC\r\n// This prevents hardcoded secrets in renderer code\r\n// ============================================\r\n\r\n// ICE servers will be populated from main process\r\nlet ICE_SERVERS: RTCIceServer[] = [\r\n  // Fallback STUN servers (no credentials needed)\r\n  { urls: 'stun:stun.l.google.com:19302' },\r\n  { urls: 'stun:stun1.l.google.com:19302' }\r\n]\r\n\r\n// Flag to track if credentials have been loaded\r\nlet credentialsLoaded = false\r\nlet credentialsLoadPromise: Promise<void> | null = null\r\n\r\n/**\r\n * Load credentials from main process\r\n * This should be called before joining a room\r\n */\r\nexport async function loadCredentials(): Promise<void> {\r\n  // Return existing promise if loading is already in progress\r\n  if (credentialsLoadPromise) {\r\n    return credentialsLoadPromise\r\n  }\r\n\r\n  // Skip if already loaded\r\n  if (credentialsLoaded) {\r\n    return\r\n  }\r\n\r\n  credentialsLoadPromise = (async () => {\r\n    try {\r\n      // Check if we're in Electron environment\r\n      if (typeof window !== 'undefined' && (window as any).electronAPI) {\r\n        SignalingLog.info('Loading credentials from main process...')\r\n\r\n        // Load ICE servers (STUN + TURN)\r\n        const iceServers = await (window as any).electronAPI.getICEServers()\r\n        if (iceServers && iceServers.length > 0) {\r\n          ICE_SERVERS = iceServers\r\n          SignalingLog.info('ICE servers loaded', { count: iceServers.length })\r\n        }\r\n\r\n        // Load MQTT brokers\r\n        const mqttBrokers = await (window as any).electronAPI.getMQTTBrokers()\r\n        if (mqttBrokers && mqttBrokers.length > 0) {\r\n          MQTT_BROKERS.length = 0  // Clear existing\r\n          mqttBrokers.forEach((broker: BrokerConfig) => MQTT_BROKERS.push(broker))\r\n          SignalingLog.info('MQTT brokers loaded', { count: mqttBrokers.length })\r\n        }\r\n\r\n        credentialsLoaded = true\r\n        SignalingLog.info('Credentials loaded successfully')\r\n      } else {\r\n        SignalingLog.warn('Not in Electron environment, using fallback STUN servers only')\r\n      }\r\n    } catch (err) {\r\n      SignalingLog.error('Failed to load credentials', { error: String(err) })\r\n      // Continue with fallback servers\r\n    } finally {\r\n      credentialsLoadPromise = null\r\n    }\r\n  })()\r\n\r\n  return credentialsLoadPromise\r\n}\r\n\r\n// Timing constants\r\nconst ANNOUNCE_INTERVAL = 3000\r\nconst ANNOUNCE_DURATION = 60000\r\nconst MQTT_KEEPALIVE = 20000\r\nconst MAX_ICE_RESTART_ATTEMPTS = 3\r\nconst ICE_RESTART_DELAY = 2000\r\nconst ICE_DISCONNECT_GRACE_PERIOD = 5000  // Wait this long before triggering ICE restart\r\nconst ICE_FAILED_TIMEOUT = 15000  // How long to wait for ICE restart before giving up\r\nconst ANNOUNCE_DEBOUNCE = 100\r\nconst MQTT_CONNECT_TIMEOUT = 8000\r\n\r\n// Message deduplication settings\r\nconst MESSAGE_DEDUP_WINDOW_SIZE = 500      // Max messages to track\r\nconst MESSAGE_DEDUP_TTL_MS = 30000         // 30 seconds TTL for dedup entries\r\n\r\n// Reconnection settings\r\nconst RECONNECT_BASE_DELAY = 2000\r\nconst RECONNECT_MAX_DELAY = 30000\r\nconst RECONNECT_MAX_ATTEMPTS = 5\r\n\r\ninterface BrokerConfig {\r\n  url: string\r\n  username?: string\r\n  password?: string\r\n}\r\n\r\n// Multiple MQTT brokers for redundancy - we connect to ALL of them\r\n// and broadcast on all connected brokers to maximize connectivity\r\n// NOTE: This array is populated from main process via loadCredentials()\r\nconst MQTT_BROKERS: BrokerConfig[] = [\r\n  // Fallback public brokers (no credentials needed)\r\n  // Private broker with credentials will be added from main process\r\n  { url: 'wss://broker.emqx.io:8084/mqtt' }, // Global EMQX (most reliable)\r\n  { url: 'wss://broker-cn.emqx.io:8084/mqtt' }, // China EMQX  \r\n  { url: 'wss://test.mosquitto.org:8081/mqtt' } // Mosquitto public broker\r\n]\r\n\r\ninterface SignalMessage {\r\n  v: number\r\n  type: 'announce' | 'offer' | 'answer' | 'ice-candidate' | 'leave' | 'ping' | 'pong' | 'mute-status'\r\n  from: string\r\n  to?: string\r\n  data?: any\r\n  userName?: string\r\n  platform?: 'win' | 'mac' | 'linux'\r\n  ts?: number\r\n  sessionId?: number\r\n  msgId?: string  // Unique message ID for deduplication\r\n}\r\n\r\ninterface MuteStatus {\r\n  micMuted: boolean\r\n  speakerMuted: boolean\r\n}\r\n\r\ninterface PeerConnection {\r\n  pc: RTCPeerConnection\r\n  stream: MediaStream | null\r\n  userName: string\r\n  platform: 'win' | 'mac' | 'linux'\r\n  connectionStartTime: number\r\n  isConnected: boolean\r\n  muteStatus: MuteStatus\r\n  iceRestartAttempts: number\r\n  iceRestartInProgress: boolean\r\n  disconnectTimer: NodeJS.Timeout | null\r\n  reconnectTimer: NodeJS.Timeout | null\r\n}\r\n\r\ntype PeerEventCallback = (peerId: string, userName: string, platform: 'win' | 'mac' | 'linux') => void\r\ntype StreamCallback = (peerId: string, stream: MediaStream) => void\r\ntype ErrorCallback = (error: Error, context: string) => void\r\ntype MuteStatusCallback = (peerId: string, muteStatus: MuteStatus) => void\r\n\r\nexport type SignalingState = 'idle' | 'connecting' | 'connected' | 'failed'\r\n\r\n/**\r\n * Generate a unique message ID for deduplication\r\n */\r\nfunction generateMessageId(): string {\r\n  return `${selfId}-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`\r\n}\r\n\r\n/**\r\n * Message deduplication cache using a sliding window with TTL\r\n * Prevents processing the same message received from multiple brokers\r\n */\r\nclass MessageDeduplicator {\r\n  private seen: Map<string, number> = new Map()  // msgId -> timestamp\r\n  private cleanupInterval: NodeJS.Timeout | null = null\r\n\r\n  constructor() {\r\n    // Periodic cleanup of old entries\r\n    this.cleanupInterval = setInterval(() => this.cleanup(), MESSAGE_DEDUP_TTL_MS / 2)\r\n  }\r\n\r\n  /**\r\n   * Check if message was already seen. If not, mark it as seen.\r\n   * @returns true if this is a duplicate, false if it's new\r\n   */\r\n  isDuplicate(msgId: string): boolean {\r\n    if (!msgId) return false  // No ID = can't dedupe, treat as new\r\n\r\n    if (this.seen.has(msgId)) {\r\n      return true\r\n    }\r\n\r\n    // Add to seen set\r\n    this.seen.set(msgId, Date.now())\r\n\r\n    // If we exceed window size, remove oldest entries\r\n    if (this.seen.size > MESSAGE_DEDUP_WINDOW_SIZE) {\r\n      const entries = Array.from(this.seen.entries())\r\n      entries.sort((a, b) => a[1] - b[1])  // Sort by timestamp ascending\r\n      const toRemove = entries.slice(0, entries.length - MESSAGE_DEDUP_WINDOW_SIZE)\r\n      toRemove.forEach(([key]) => this.seen.delete(key))\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Remove entries older than TTL\r\n   */\r\n  private cleanup() {\r\n    const cutoff = Date.now() - MESSAGE_DEDUP_TTL_MS\r\n    const toDelete: string[] = []\r\n\r\n    this.seen.forEach((timestamp, msgId) => {\r\n      if (timestamp < cutoff) {\r\n        toDelete.push(msgId)\r\n      }\r\n    })\r\n\r\n    toDelete.forEach(msgId => this.seen.delete(msgId))\r\n\r\n    if (toDelete.length > 0) {\r\n      SignalingLog.debug('Dedup cache cleanup', { removed: toDelete.length, remaining: this.seen.size })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all entries and stop cleanup timer\r\n   */\r\n  destroy() {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval)\r\n      this.cleanupInterval = null\r\n    }\r\n    this.seen.clear()\r\n  }\r\n\r\n  /**\r\n   * Get current cache size (for debugging)\r\n   */\r\n  size(): number {\r\n    return this.seen.size\r\n  }\r\n}\r\n\r\n/**\r\n * Single MQTT broker connection with keepalive and proper buffer handling\r\n */\r\nclass MQTTClient {\r\n  private ws: WebSocket | null = null\r\n  private connected = false\r\n  private subscribed = false\r\n  private messageId = 1\r\n  private clientId: string\r\n  private topic: string = ''\r\n  private onMessage: ((payload: string) => void) | null = null\r\n  private buffer: Uint8Array = new Uint8Array(0)\r\n  private keepaliveInterval: NodeJS.Timeout | null = null\r\n  private pendingSubscribe: { resolve: () => void; reject: (err: Error) => void } | null = null\r\n  private subscribeTimeout: NodeJS.Timeout | null = null\r\n  private messageCount = 0\r\n  private brokerUrl: string = ''\r\n  private onDisconnectCallback: ((brokerUrl: string) => void) | null = null\r\n  private isIntentionallyClosed = false\r\n  private username?: string\r\n  private password?: string\r\n\r\n  constructor(brokerUrl: string, username?: string, password?: string) {\r\n    this.brokerUrl = brokerUrl\r\n    this.username = username\r\n    this.password = password\r\n    // Include broker identifier in client ID to avoid conflicts\r\n    const brokerHash = brokerUrl.split('//')[1]?.split('.')[0] || 'unknown'\r\n    this.clientId = `p2p_${selfId.substring(0, 6)}_${brokerHash}_${Math.random().toString(36).substring(2, 4)}`\r\n  }\r\n\r\n  getBrokerUrl(): string {\r\n    return this.brokerUrl\r\n  }\r\n\r\n  /**\r\n   * Set callback for disconnect events\r\n   */\r\n  setOnDisconnect(callback: (brokerUrl: string) => void) {\r\n    this.onDisconnectCallback = callback\r\n  }\r\n\r\n  connect(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (this.connected) {\r\n        resolve()\r\n        return\r\n      }\r\n\r\n      this.isIntentionallyClosed = false\r\n\r\n      try {\r\n        this.ws = new WebSocket(this.brokerUrl, 'mqtt')\r\n        this.ws.binaryType = 'arraybuffer'\r\n        this.buffer = new Uint8Array(0)\r\n\r\n        const timeout = setTimeout(() => {\r\n          if (!this.connected) {\r\n            this.disconnect()\r\n            reject(new Error(`MQTT connection timeout: ${this.brokerUrl}`))\r\n          }\r\n        }, MQTT_CONNECT_TIMEOUT)\r\n\r\n        this.ws.onopen = () => {\r\n          this.sendConnect()\r\n        }\r\n\r\n        this.ws.onmessage = (event) => {\r\n          this.appendToBuffer(new Uint8Array(event.data))\r\n          this.processBuffer()\r\n\r\n          if (!this.connected) {\r\n            this.connected = true\r\n            clearTimeout(timeout)\r\n            this.startKeepalive()\r\n            resolve()\r\n          }\r\n        }\r\n\r\n        this.ws.onerror = () => {\r\n          clearTimeout(timeout)\r\n          if (!this.connected) {\r\n            reject(new Error(`MQTT WebSocket error: ${this.brokerUrl}`))\r\n          }\r\n        }\r\n\r\n        this.ws.onclose = () => {\r\n          const wasConnected = this.connected\r\n          this.connected = false\r\n          this.subscribed = false\r\n          this.stopKeepalive()\r\n\r\n          // Only trigger disconnect callback if this wasn't intentional\r\n          if (wasConnected && !this.isIntentionallyClosed && this.onDisconnectCallback) {\r\n            SignalingLog.warn('MQTT broker disconnected unexpectedly', { broker: this.brokerUrl })\r\n            this.onDisconnectCallback(this.brokerUrl)\r\n          }\r\n        }\r\n      } catch (err) {\r\n        reject(err)\r\n      }\r\n    })\r\n  }\r\n\r\n  private startKeepalive() {\r\n    this.stopKeepalive()\r\n    this.keepaliveInterval = setInterval(() => {\r\n      if (this.ws?.readyState === WebSocket.OPEN) {\r\n        this.ws.send(new Uint8Array([0xC0, 0x00]))  // PINGREQ\r\n      }\r\n    }, MQTT_KEEPALIVE)\r\n  }\r\n\r\n  private stopKeepalive() {\r\n    if (this.keepaliveInterval) {\r\n      clearInterval(this.keepaliveInterval)\r\n      this.keepaliveInterval = null\r\n    }\r\n  }\r\n\r\n  private appendToBuffer(data: Uint8Array) {\r\n    const newBuffer = new Uint8Array(this.buffer.length + data.length)\r\n    newBuffer.set(this.buffer)\r\n    newBuffer.set(data, this.buffer.length)\r\n    this.buffer = newBuffer\r\n  }\r\n\r\n  private processBuffer() {\r\n    while (this.buffer.length > 0) {\r\n      const packet = this.tryReadPacket()\r\n      if (!packet) break\r\n      this.handlePacket(packet)\r\n    }\r\n  }\r\n\r\n  private tryReadPacket(): Uint8Array | null {\r\n    if (this.buffer.length < 2) return null\r\n\r\n    let multiplier = 1\r\n    let remainingLength = 0\r\n    let idx = 1\r\n\r\n    while (idx < this.buffer.length) {\r\n      const byte = this.buffer[idx]\r\n      remainingLength += (byte & 0x7F) * multiplier\r\n      multiplier *= 128\r\n      idx++\r\n\r\n      if ((byte & 0x80) === 0) break\r\n      if (idx > 4) {\r\n        // Invalid remaining length encoding, clear buffer\r\n        this.buffer = new Uint8Array(0)\r\n        return null\r\n      }\r\n    }\r\n\r\n    if (idx >= this.buffer.length) return null\r\n\r\n    const totalLength = idx + remainingLength\r\n    if (this.buffer.length < totalLength) return null\r\n\r\n    const packet = this.buffer.slice(0, totalLength)\r\n    this.buffer = this.buffer.slice(totalLength)\r\n    return packet\r\n  }\r\n\r\n  private sendConnect() {\r\n    const clientIdBytes = new TextEncoder().encode(this.clientId)\r\n    const protocolName = new TextEncoder().encode('MQTT')\r\n\r\n    let usernameBytes = new Uint8Array(0)\r\n    let passwordBytes = new Uint8Array(0)\r\n\r\n    if (this.username) {\r\n      usernameBytes = new TextEncoder().encode(this.username)\r\n    }\r\n    if (this.password) {\r\n      passwordBytes = new TextEncoder().encode(this.password)\r\n    }\r\n\r\n    // Variable Header (10 bytes) + Client ID (2 len + bytes)\r\n    let payloadLength = 10 + (2 + clientIdBytes.length)\r\n\r\n    if (this.username) {\r\n      payloadLength += (2 + usernameBytes.length)\r\n    }\r\n    if (this.password) {\r\n      payloadLength += (2 + passwordBytes.length)\r\n    }\r\n\r\n    const lengthBytes: number[] = []\r\n    let x = payloadLength\r\n    do {\r\n      let byte = x % 128\r\n      x = Math.floor(x / 128)\r\n      if (x > 0) byte |= 0x80\r\n      lengthBytes.push(byte)\r\n    } while (x > 0)\r\n\r\n    const packet = new Uint8Array(1 + lengthBytes.length + payloadLength)\r\n    let i = 0\r\n\r\n    // --- Fixed Header ---\r\n    packet[i++] = 0x10  // CONNECT Packet Type\r\n\r\n    for (const b of lengthBytes) {\r\n      packet[i++] = b\r\n    }\r\n\r\n    // --- Variable Header ---\r\n    packet[i++] = 0     // Protocol Name Length MSB\r\n    packet[i++] = 4     // Protocol Name Length LSB\r\n    packet.set(protocolName, i)\r\n    i += 4\r\n\r\n    packet[i++] = 4     // Protocol Level (MQTT 3.1.1)\r\n\r\n    // Connect Flags\r\n    // Clean Session (bit 1) = 2\r\n    // Username Flag (bit 7) = 0x80\r\n    // Password Flag (bit 6) = 0x40\r\n    let connectFlags = 2\r\n    if (this.username) connectFlags |= 0x80\r\n    if (this.password) connectFlags |= 0x40\r\n    packet[i++] = connectFlags\r\n\r\n    packet[i++] = 0     // Keep Alive MSB\r\n    packet[i++] = 30    // Keep Alive LSB (30 seconds)\r\n\r\n    // --- Payload ---\r\n    // Client ID\r\n    packet[i++] = (clientIdBytes.length >> 8) & 0xff\r\n    packet[i++] = clientIdBytes.length & 0xff\r\n    packet.set(clientIdBytes, i)\r\n    i += clientIdBytes.length\r\n\r\n    // User Name\r\n    if (this.username) {\r\n      packet[i++] = (usernameBytes.length >> 8) & 0xff\r\n      packet[i++] = usernameBytes.length & 0xff\r\n      packet.set(usernameBytes, i)\r\n      i += usernameBytes.length\r\n    }\r\n\r\n    // Password\r\n    if (this.password) {\r\n      packet[i++] = (passwordBytes.length >> 8) & 0xff\r\n      packet[i++] = passwordBytes.length & 0xff\r\n      packet.set(passwordBytes, i)\r\n      i += passwordBytes.length\r\n    }\r\n\r\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\r\n      this.ws.send(packet)\r\n    }\r\n  }\r\n\r\n  async subscribe(topic: string, callback: (message: string) => void): Promise<boolean> {\r\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\r\n      SignalingLog.error('MQTT subscribe failed - not connected', { broker: this.brokerUrl })\r\n      return false\r\n    }\r\n\r\n    this.topic = topic\r\n    this.onMessage = callback\r\n    this.subscribed = false\r\n\r\n    const topicBytes = new TextEncoder().encode(topic)\r\n    const remainingLength = 2 + 2 + topicBytes.length + 1\r\n    const packet = new Uint8Array(2 + remainingLength)\r\n\r\n    let i = 0\r\n    packet[i++] = 0x82  // SUBSCRIBE packet type\r\n    packet[i++] = remainingLength\r\n    packet[i++] = (this.messageId >> 8) & 0xff\r\n    packet[i++] = this.messageId++ & 0xff\r\n    packet[i++] = (topicBytes.length >> 8) & 0xff\r\n    packet[i++] = topicBytes.length & 0xff\r\n    packet.set(topicBytes, i)\r\n    i += topicBytes.length\r\n    packet[i++] = 0     // QoS 0\r\n\r\n    return new Promise((resolve) => {\r\n      this.pendingSubscribe = {\r\n        resolve: () => resolve(true),\r\n        reject: () => resolve(false)\r\n      }\r\n\r\n      this.subscribeTimeout = setTimeout(() => {\r\n        if (!this.subscribed) {\r\n          SignalingLog.warn('MQTT SUBACK timeout', { broker: this.brokerUrl })\r\n          this.pendingSubscribe?.reject(new Error('Subscription timeout'))\r\n          this.pendingSubscribe = null\r\n        }\r\n      }, 5000)\r\n\r\n      try {\r\n        this.ws!.send(packet)\r\n      } catch (err) {\r\n        SignalingLog.error('MQTT subscribe send error', { broker: this.brokerUrl, error: String(err) })\r\n        clearTimeout(this.subscribeTimeout)\r\n        this.pendingSubscribe = null\r\n        resolve(false)\r\n      }\r\n    })\r\n  }\r\n\r\n  publish(topic: string, message: string): boolean {\r\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\r\n      return false\r\n    }\r\n\r\n    const topicBytes = new TextEncoder().encode(topic)\r\n    const messageBytes = new TextEncoder().encode(message)\r\n    const remainingLength = 2 + topicBytes.length + messageBytes.length\r\n\r\n    // Encode remaining length (variable length encoding)\r\n    const lengthBytes: number[] = []\r\n    let x = remainingLength\r\n    do {\r\n      let byte = x % 128\r\n      x = Math.floor(x / 128)\r\n      if (x > 0) byte |= 0x80\r\n      lengthBytes.push(byte)\r\n    } while (x > 0)\r\n\r\n    const packet = new Uint8Array(1 + lengthBytes.length + remainingLength)\r\n\r\n    let i = 0\r\n    packet[i++] = 0x30  // PUBLISH packet type (QoS 0)\r\n    for (const b of lengthBytes) {\r\n      packet[i++] = b\r\n    }\r\n    packet[i++] = (topicBytes.length >> 8) & 0xff\r\n    packet[i++] = topicBytes.length & 0xff\r\n    packet.set(topicBytes, i)\r\n    i += topicBytes.length\r\n    packet.set(messageBytes, i)\r\n\r\n    try {\r\n      this.ws.send(packet)\r\n      return true\r\n    } catch (err) {\r\n      SignalingLog.error('MQTT publish error', { broker: this.brokerUrl, error: String(err) })\r\n      return false\r\n    }\r\n  }\r\n\r\n  private handlePacket(data: Uint8Array) {\r\n    const packetType = data[0] >> 4\r\n\r\n    if (packetType === 2) {\r\n      // CONNACK\r\n      SignalingLog.debug('MQTT CONNACK received', { broker: this.brokerUrl })\r\n    } else if (packetType === 3) {\r\n      // PUBLISH\r\n      const qos = (data[0] & 0x06) >> 1\r\n\r\n      let idx = 1\r\n      let multiplier = 1\r\n      let remainingLength = 0\r\n\r\n      while (idx < data.length) {\r\n        const byte = data[idx]\r\n        remainingLength += (byte & 0x7F) * multiplier\r\n        multiplier *= 128\r\n        idx++\r\n        if ((byte & 0x80) === 0) break\r\n      }\r\n\r\n      if (idx + 2 > data.length) return\r\n\r\n      const topicLen = (data[idx] << 8) | data[idx + 1]\r\n      idx += 2\r\n\r\n      if (idx + topicLen > data.length) return\r\n\r\n      idx += topicLen  // Skip topic\r\n\r\n      // Skip packet identifier for QoS > 0\r\n      if (qos > 0) {\r\n        idx += 2\r\n      }\r\n\r\n      const payloadBytes = data.slice(idx)\r\n      const payload = new TextDecoder().decode(payloadBytes)\r\n\r\n      this.messageCount++\r\n\r\n      if (this.onMessage && payload.length > 0) {\r\n        this.onMessage(payload)\r\n      }\r\n    } else if (packetType === 9) {\r\n      // SUBACK\r\n      this.subscribed = true\r\n      SignalingLog.info('MQTT SUBACK received', { broker: this.brokerUrl, topic: this.topic })\r\n\r\n      if (this.subscribeTimeout) {\r\n        clearTimeout(this.subscribeTimeout)\r\n        this.subscribeTimeout = null\r\n      }\r\n      if (this.pendingSubscribe) {\r\n        this.pendingSubscribe.resolve()\r\n        this.pendingSubscribe = null\r\n      }\r\n    } else if (packetType === 13) {\r\n      // PINGRESP\r\n      SignalingLog.debug('MQTT PINGRESP', { broker: this.brokerUrl })\r\n    }\r\n  }\r\n\r\n  disconnect() {\r\n    this.isIntentionallyClosed = true\r\n    this.stopKeepalive()\r\n\r\n    if (this.subscribeTimeout) {\r\n      clearTimeout(this.subscribeTimeout)\r\n      this.subscribeTimeout = null\r\n    }\r\n    this.pendingSubscribe = null\r\n    this.onDisconnectCallback = null\r\n\r\n    if (this.ws) {\r\n      try {\r\n        if (this.ws.readyState === WebSocket.OPEN) {\r\n          this.ws.send(new Uint8Array([0xe0, 0x00]))  // DISCONNECT\r\n        }\r\n      } catch { /* ignore send errors on disconnect */ }\r\n      this.ws.close()\r\n      this.ws = null\r\n    }\r\n\r\n    this.connected = false\r\n    this.subscribed = false\r\n    this.onMessage = null\r\n    this.messageCount = 0\r\n  }\r\n\r\n  isConnected(): boolean {\r\n    return this.connected && this.ws?.readyState === WebSocket.OPEN\r\n  }\r\n\r\n  isSubscribed(): boolean {\r\n    return this.subscribed\r\n  }\r\n\r\n  getMessageCount(): number {\r\n    return this.messageCount\r\n  }\r\n}\r\n\r\n/**\r\n * Multi-broker MQTT manager that connects to ALL brokers simultaneously\r\n * and handles message deduplication across brokers\r\n */\r\nclass MultiBrokerMQTT {\r\n  private clients: Map<string, MQTTClient> = new Map()  // brokerUrl -> client\r\n  private topic: string = ''\r\n  private onMessage: ((payload: string) => void) | null = null\r\n  private deduplicator: MessageDeduplicator = new MessageDeduplicator()\r\n  private reconnectAttempts: Map<string, number> = new Map()\r\n  private reconnectTimers: Map<string, NodeJS.Timeout> = new Map()\r\n  private isShuttingDown = false\r\n  private onReconnect: ((brokerUrl: string) => void) | null = null\r\n\r\n  /**\r\n   * Set callback for broker reconnection events\r\n   * This is called when a broker successfully reconnects and resubscribes\r\n   */\r\n  setOnReconnect(callback: (brokerUrl: string) => void) {\r\n    this.onReconnect = callback\r\n  }\r\n\r\n  /**\r\n   * Connect to all configured MQTT brokers in parallel\r\n   * @returns Array of successfully connected broker URLs\r\n   */\r\n  async connectAll(): Promise<string[]> {\r\n    this.isShuttingDown = false\r\n    const connectedBrokers: string[] = []\r\n\r\n    SignalingLog.info('Connecting to all MQTT brokers', { count: MQTT_BROKERS.length })\r\n\r\n    // Connect to all brokers in parallel\r\n    const results = await Promise.allSettled(\r\n      MQTT_BROKERS.map(async (brokerConfig) => {\r\n        const brokerUrl = brokerConfig.url\r\n        const client = new MQTTClient(brokerUrl, brokerConfig.username, brokerConfig.password)\r\n\r\n        // Set up disconnect handler for reconnection\r\n        client.setOnDisconnect((url) => {\r\n          if (!this.isShuttingDown) {\r\n            this.handleBrokerDisconnect(url, brokerConfig.username, brokerConfig.password)\r\n          }\r\n        })\r\n\r\n        try {\r\n          await client.connect()\r\n          this.clients.set(brokerUrl, client)\r\n          this.reconnectAttempts.set(brokerUrl, 0)  // Reset attempts on success\r\n          SignalingLog.info('MQTT broker connected', { broker: brokerUrl })\r\n          return brokerUrl\r\n        } catch (err) {\r\n          SignalingLog.warn('MQTT broker failed to connect', { broker: brokerUrl, error: String(err) })\r\n          throw err\r\n        }\r\n      })\r\n    )\r\n\r\n    // Collect successful connections\r\n    results.forEach((result) => {\r\n      if (result.status === 'fulfilled') {\r\n        connectedBrokers.push(result.value)\r\n      }\r\n    })\r\n\r\n    SignalingLog.info('MQTT connection results', {\r\n      total: MQTT_BROKERS.length,\r\n      connected: connectedBrokers.length,\r\n      brokers: connectedBrokers\r\n    })\r\n\r\n    return connectedBrokers\r\n  }\r\n\r\n  /**\r\n   * Handle unexpected broker disconnect with exponential backoff reconnection\r\n   */\r\n  private async handleBrokerDisconnect(brokerUrl: string, username?: string, password?: string) {\r\n    if (this.isShuttingDown) return\r\n\r\n    // Clean up old client\r\n    const oldClient = this.clients.get(brokerUrl)\r\n    if (oldClient) {\r\n      oldClient.disconnect()\r\n      this.clients.delete(brokerUrl)\r\n    }\r\n\r\n    const attempts = (this.reconnectAttempts.get(brokerUrl) || 0) + 1\r\n    this.reconnectAttempts.set(brokerUrl, attempts)\r\n\r\n    if (attempts > RECONNECT_MAX_ATTEMPTS) {\r\n      SignalingLog.warn('Max reconnect attempts reached for broker', { broker: brokerUrl, attempts })\r\n      return\r\n    }\r\n\r\n    // Exponential backoff with jitter\r\n    const baseDelay = Math.min(RECONNECT_BASE_DELAY * Math.pow(2, attempts - 1), RECONNECT_MAX_DELAY)\r\n    const jitter = Math.random() * 1000\r\n    const delay = baseDelay + jitter\r\n\r\n    SignalingLog.info('Scheduling MQTT reconnection', { broker: brokerUrl, attempt: attempts, delayMs: Math.round(delay) })\r\n\r\n    // Clear any existing reconnect timer\r\n    const existingTimer = this.reconnectTimers.get(brokerUrl)\r\n    if (existingTimer) {\r\n      clearTimeout(existingTimer)\r\n    }\r\n\r\n    // Schedule reconnection\r\n    const timer = setTimeout(async () => {\r\n      if (this.isShuttingDown) return\r\n\r\n      try {\r\n        const client = new MQTTClient(brokerUrl, username, password)\r\n        client.setOnDisconnect((url) => {\r\n          if (!this.isShuttingDown) {\r\n            this.handleBrokerDisconnect(url, username, password)\r\n          }\r\n        })\r\n\r\n        await client.connect()\r\n        this.clients.set(brokerUrl, client)\r\n\r\n        // Re-subscribe if we have a topic\r\n        if (this.topic && this.onMessage) {\r\n          const subscribed = await client.subscribe(this.topic, this.onMessage)\r\n          if (subscribed) {\r\n            SignalingLog.info('MQTT broker reconnected and resubscribed', { broker: brokerUrl })\r\n            this.reconnectAttempts.set(brokerUrl, 0)  // Reset on success\r\n\r\n            // Trigger a re-announce event so SimplePeerManager can re-broadcast presence\r\n            // This helps with network recovery scenarios\r\n            if (this.onReconnect) {\r\n              SignalingLog.info('Triggering reconnection callback for re-announcement')\r\n              this.onReconnect(brokerUrl)\r\n            }\r\n          } else {\r\n            SignalingLog.warn('MQTT broker reconnected but subscribe failed', { broker: brokerUrl })\r\n          }\r\n        }\r\n      } catch (err) {\r\n        SignalingLog.warn('MQTT reconnection failed', { broker: brokerUrl, attempt: attempts, error: String(err) })\r\n        // Schedule another retry since this attempt failed\r\n        if (!this.isShuttingDown) {\r\n          this.handleBrokerDisconnect(brokerUrl, username, password)\r\n        }\r\n      }\r\n    }, delay)\r\n\r\n    this.reconnectTimers.set(brokerUrl, timer)\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a topic on all connected brokers\r\n   * @returns Number of successful subscriptions\r\n   */\r\n  async subscribeAll(topic: string, callback: (message: string) => void): Promise<number> {\r\n    this.topic = topic\r\n\r\n    // Wrap callback with deduplication\r\n    this.onMessage = (payload: string) => {\r\n      try {\r\n        const data = JSON.parse(payload)\r\n        const msgId = data.msgId\r\n\r\n        // Check for duplicates\r\n        if (msgId && this.deduplicator.isDuplicate(msgId)) {\r\n          SignalingLog.debug('Duplicate message filtered', { msgId: msgId.substring(0, 20) })\r\n          return\r\n        }\r\n\r\n        // Pass through to actual callback\r\n        callback(payload)\r\n      } catch {\r\n        // If we can't parse, just pass through (shouldn't happen in normal operation)\r\n        callback(payload)\r\n      }\r\n    }\r\n\r\n    let successCount = 0\r\n\r\n    // Subscribe on all clients in parallel\r\n    const results = await Promise.allSettled(\r\n      Array.from(this.clients.entries()).map(async ([brokerUrl, client]) => {\r\n        const success = await client.subscribe(topic, this.onMessage!)\r\n        if (success) {\r\n          SignalingLog.info('Subscribed on broker', { broker: brokerUrl, topic })\r\n          return brokerUrl\r\n        } else {\r\n          throw new Error(`Subscribe failed on ${brokerUrl}`)\r\n        }\r\n      })\r\n    )\r\n\r\n    results.forEach(result => {\r\n      if (result.status === 'fulfilled') {\r\n        successCount++\r\n      }\r\n    })\r\n\r\n    SignalingLog.info('Subscription results', { total: this.clients.size, subscribed: successCount })\r\n\r\n    return successCount\r\n  }\r\n\r\n  /**\r\n   * Publish a message to ALL connected brokers\r\n   * @returns Number of successful publishes\r\n   */\r\n  publish(topic: string, message: string): number {\r\n    let successCount = 0\r\n\r\n    this.clients.forEach((client) => {\r\n      if (client.isConnected() && client.isSubscribed()) {\r\n        if (client.publish(topic, message)) {\r\n          successCount++\r\n        }\r\n      }\r\n    })\r\n\r\n    return successCount\r\n  }\r\n\r\n  /**\r\n   * Disconnect from all brokers and clean up\r\n   */\r\n  disconnect() {\r\n    this.isShuttingDown = true\r\n\r\n    // Clear all reconnect timers\r\n    this.reconnectTimers.forEach((timer) => {\r\n      clearTimeout(timer)\r\n    })\r\n    this.reconnectTimers.clear()\r\n    this.reconnectAttempts.clear()\r\n\r\n    // Disconnect all clients\r\n    this.clients.forEach((client) => {\r\n      client.disconnect()\r\n    })\r\n    this.clients.clear()\r\n\r\n    // Clean up deduplicator\r\n    this.deduplicator.destroy()\r\n    this.deduplicator = new MessageDeduplicator()  // Create fresh instance for next use\r\n\r\n    this.topic = ''\r\n    this.onMessage = null\r\n  }\r\n\r\n  /**\r\n   * Check if at least one broker is connected\r\n   */\r\n  isConnected(): boolean {\r\n    for (const client of this.clients.values()) {\r\n      if (client.isConnected()) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Check if at least one broker is subscribed\r\n   */\r\n  isSubscribed(): boolean {\r\n    for (const client of this.clients.values()) {\r\n      if (client.isSubscribed()) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Get total message count across all brokers\r\n   */\r\n  getTotalMessageCount(): number {\r\n    let total = 0\r\n    this.clients.forEach(client => {\r\n      total += client.getMessageCount()\r\n    })\r\n    return total\r\n  }\r\n\r\n  /**\r\n   * Get connection status for all brokers\r\n   */\r\n  getConnectionStatus(): { broker: string; connected: boolean; subscribed: boolean }[] {\r\n    return Array.from(this.clients.entries()).map(([broker, client]) => ({\r\n      broker,\r\n      connected: client.isConnected(),\r\n      subscribed: client.isSubscribed()\r\n    }))\r\n  }\r\n\r\n  /**\r\n   * Get number of connected brokers\r\n   */\r\n  getConnectedCount(): number {\r\n    let count = 0\r\n    this.clients.forEach(client => {\r\n      if (client.isConnected()) count++\r\n    })\r\n    return count\r\n  }\r\n\r\n  /**\r\n   * Get deduplication cache size (for debugging)\r\n   */\r\n  getDeduplicatorSize(): number {\r\n    return this.deduplicator.size()\r\n  }\r\n}\r\n\r\nexport class SimplePeerManager {\r\n  private roomId: string | null = null\r\n  private userName: string = ''\r\n  private localPlatform: 'win' | 'mac' | 'linux' = 'win'  // Default to win, set properly on init\r\n  private mqtt: MultiBrokerMQTT | null = null\r\n  private topic: string = ''\r\n  private peers: Map<string, PeerConnection> = new Map()\r\n  private localStream: MediaStream | null = null\r\n  private pendingCandidates: Map<string, RTCIceCandidateInit[]> = new Map()\r\n  private broadcastChannel: BroadcastChannel | null = null\r\n  private announceInterval: NodeJS.Timeout | null = null\r\n  private announceStartTime: number = 0\r\n  private localMuteStatus: MuteStatus = { micMuted: false, speakerMuted: false }\r\n\r\n  // Session tracking to prevent stale messages after rejoin\r\n  private sessionId: number = 0\r\n\r\n  // Guards against concurrent join/leave operations\r\n  private isJoining: boolean = false\r\n  private isLeaving: boolean = false\r\n\r\n  // Debounce timer for announce messages\r\n  private announceDebounceTimer: NodeJS.Timeout | null = null\r\n\r\n  // Signaling state tracking\r\n  private signalingState: SignalingState = 'idle'\r\n  private onSignalingStateChange: ((state: SignalingState) => void) | null = null\r\n\r\n  private onPeerJoin: PeerEventCallback = () => { }\r\n  private onPeerLeave: PeerEventCallback = () => { }\r\n  private onRemoteStream: StreamCallback = () => { }\r\n  private onError: ErrorCallback = () => { }\r\n  private onPeerMuteChange: MuteStatusCallback = () => { }\r\n\r\n  constructor() {\r\n    SignalingLog.info('SimplePeerManager initialized', { selfId })\r\n  }\r\n\r\n  /**\r\n   * Set callback for signaling state changes\r\n   */\r\n  setOnSignalingStateChange(callback: (state: SignalingState) => void) {\r\n    this.onSignalingStateChange = callback\r\n  }\r\n\r\n  private updateSignalingState(state: SignalingState) {\r\n    if (this.signalingState !== state) {\r\n      this.signalingState = state\r\n      SignalingLog.info('Signaling state changed', { state })\r\n      this.onSignalingStateChange?.(state)\r\n    }\r\n  }\r\n\r\n  getSignalingState(): SignalingState {\r\n    return this.signalingState\r\n  }\r\n\r\n  setCallbacks(callbacks: {\r\n    onPeerJoin?: PeerEventCallback\r\n    onPeerLeave?: PeerEventCallback\r\n    onRemoteStream?: StreamCallback\r\n    onError?: ErrorCallback\r\n    onPeerMuteChange?: MuteStatusCallback\r\n  }) {\r\n    if (callbacks.onPeerJoin) this.onPeerJoin = callbacks.onPeerJoin\r\n    if (callbacks.onPeerLeave) this.onPeerLeave = callbacks.onPeerLeave\r\n    if (callbacks.onRemoteStream) this.onRemoteStream = callbacks.onRemoteStream\r\n    if (callbacks.onError) this.onError = callbacks.onError\r\n    if (callbacks.onPeerMuteChange) this.onPeerMuteChange = callbacks.onPeerMuteChange\r\n  }\r\n\r\n  setLocalStream(stream: MediaStream) {\r\n    SignalingLog.info('Setting local stream', { streamId: stream.id, trackCount: stream.getTracks().length })\r\n    this.localStream = stream\r\n\r\n    // Add tracks to all existing peer connections\r\n    this.peers.forEach((peer, peerId) => {\r\n      const senders = peer.pc.getSenders()\r\n      const audioSender = senders.find(s => s.track?.kind === 'audio')\r\n\r\n      // Check if we already have an audio track added\r\n      if (audioSender && audioSender.track) {\r\n        SignalingLog.debug('Audio track already added for peer', { peerId })\r\n        return\r\n      }\r\n\r\n      // Add all tracks from the local stream\r\n      const tracks = stream.getTracks()\r\n      tracks.forEach(track => {\r\n        // Check if this track is already added\r\n        const existingSender = senders.find(s => s.track === track)\r\n        if (existingSender) {\r\n          SignalingLog.debug('Track already added, skipping', { peerId, trackKind: track.kind })\r\n          return\r\n        }\r\n\r\n        // Check if there's a sender without a track that we can use\r\n        const emptySender = senders.find(s => s.track === null)\r\n        if (emptySender) {\r\n          SignalingLog.info('Replacing empty sender track', { peerId, trackKind: track.kind })\r\n          emptySender.replaceTrack(track)\r\n            .then(() => SignalingLog.info('Track replaced successfully', { peerId, trackKind: track.kind }))\r\n            .catch(err => SignalingLog.error('Failed to replace track', { peerId, error: String(err) }))\r\n        } else {\r\n          SignalingLog.info('Adding new track to peer', { peerId, trackKind: track.kind })\r\n          try {\r\n            peer.pc.addTrack(track, stream)\r\n          } catch (err) {\r\n            SignalingLog.error('Failed to add track', { peerId, error: String(err) })\r\n          }\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Broadcast local mute status to all peers\r\n   */\r\n  broadcastMuteStatus(micMuted: boolean, speakerMuted: boolean) {\r\n    this.localMuteStatus = { micMuted, speakerMuted }\r\n\r\n    if (this.peers.size === 0) return\r\n\r\n    SignalingLog.debug('Broadcasting mute status', { micMuted, speakerMuted })\r\n    this.broadcast({\r\n      v: 1,\r\n      type: 'mute-status',\r\n      from: selfId,\r\n      data: { micMuted, speakerMuted },\r\n      sessionId: this.sessionId,\r\n      msgId: generateMessageId()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Get mute status of a specific peer\r\n   */\r\n  getPeerMuteStatus(peerId: string): MuteStatus {\r\n    return this.peers.get(peerId)?.muteStatus ?? { micMuted: false, speakerMuted: false }\r\n  }\r\n\r\n  /**\r\n   * Get all peer mute statuses\r\n   */\r\n  getAllPeerMuteStatuses(): Map<string, MuteStatus> {\r\n    const result = new Map<string, MuteStatus>()\r\n    this.peers.forEach((peer, id) => {\r\n      result.set(id, peer.muteStatus)\r\n    })\r\n    return result\r\n  }\r\n\r\n  async joinRoom(roomId: string, userName: string): Promise<void> {\r\n    // Prevent concurrent join operations\r\n    if (this.isJoining) {\r\n      SignalingLog.warn('Join already in progress, ignoring')\r\n      return\r\n    }\r\n\r\n    // Clean up any existing connection first\r\n    if (this.roomId) {\r\n      SignalingLog.info('Cleaning up previous room before joining new one')\r\n      this.leaveRoom()\r\n      // Small delay to ensure cleanup completes\r\n      await new Promise(resolve => setTimeout(resolve, 100))\r\n    }\r\n\r\n    this.isJoining = true\r\n    this.sessionId++  // Increment session ID to invalidate any stale messages\r\n    const currentSession = this.sessionId\r\n\r\n    try {\r\n      this.updateSignalingState('connecting')\r\n\r\n      // Load credentials from main process (TURN/MQTT secrets)\r\n      // This must be done before connecting to ensure we have the latest credentials\r\n      await loadCredentials()\r\n\r\n      this.roomId = roomId\r\n      this.userName = userName\r\n      this.announceStartTime = Date.now()\r\n      this.topic = `p2p-conf/${roomId}`\r\n\r\n      // Detect local platform\r\n      const userAgent = navigator.userAgent.toLowerCase()\r\n      if (userAgent.includes('win')) {\r\n        this.localPlatform = 'win'\r\n      } else if (userAgent.includes('mac')) {\r\n        this.localPlatform = 'mac'\r\n      } else if (userAgent.includes('linux')) {\r\n        this.localPlatform = 'linux'\r\n      } else {\r\n        this.localPlatform = 'win'  // Default fallback\r\n      }\r\n\r\n      SignalingLog.info('Joining room', {\r\n        roomId, userName, selfId,\r\n        topic: this.topic,\r\n        sessionId: currentSession\r\n      })\r\n\r\n      // Close any existing BroadcastChannel first\r\n      if (this.broadcastChannel) {\r\n        try {\r\n          this.broadcastChannel.close()\r\n        } catch { /* ignore close errors */ }\r\n        this.broadcastChannel = null\r\n      }\r\n\r\n      // Set up BroadcastChannel for same-device connections\r\n      try {\r\n        this.broadcastChannel = new BroadcastChannel(`p2p-${roomId}`)\r\n        this.broadcastChannel.onmessage = (event) => {\r\n          // Verify session is still current\r\n          if (this.sessionId !== currentSession) {\r\n            SignalingLog.debug('Ignoring BroadcastChannel message from previous session')\r\n            return\r\n          }\r\n          this.handleSignalingMessage(event.data)\r\n        }\r\n        SignalingLog.debug('BroadcastChannel connected')\r\n      } catch (err) {\r\n        SignalingLog.warn('BroadcastChannel not available')\r\n      }\r\n\r\n      // Connect to ALL MQTT brokers\r\n      let connectedBrokers: string[] = []\r\n\r\n      try {\r\n        SignalingLog.info('Starting multi-broker MQTT connection')\r\n\r\n        this.mqtt = new MultiBrokerMQTT()\r\n\r\n        // Set up reconnection callback to re-announce presence after network recovery\r\n        this.mqtt.setOnReconnect((_brokerUrl) => {\r\n          // Reset announce timing for fresh discovery after network recovery\r\n          this.announceStartTime = Date.now()\r\n          this.broadcastAnnounce()\r\n          // Also restart the announce interval if we don't have peers\r\n          if (this.getHealthyPeerCount() === 0) {\r\n            this.startAnnounceInterval()\r\n          }\r\n        })\r\n\r\n        connectedBrokers = await this.mqtt.connectAll()\r\n\r\n        if (connectedBrokers.length === 0) {\r\n          throw new Error('No MQTT brokers could be connected')\r\n        }\r\n\r\n        SignalingLog.info('MQTT brokers connected', {\r\n          count: connectedBrokers.length,\r\n          brokers: connectedBrokers\r\n        })\r\n\r\n        // Subscribe on all connected brokers\r\n        const subscribeCount = await this.mqtt.subscribeAll(this.topic, (message) => {\r\n          // Verify session is still current\r\n          if (this.sessionId !== currentSession) {\r\n            SignalingLog.debug('Ignoring MQTT message from previous session')\r\n            return\r\n          }\r\n\r\n          try {\r\n            const data = JSON.parse(message)\r\n            this.handleSignalingMessage(data)\r\n          } catch (e) {\r\n            SignalingLog.debug('Invalid MQTT message', {\r\n              error: String(e),\r\n              length: message.length,\r\n              preview: message.substring(0, 50)\r\n            })\r\n          }\r\n        })\r\n\r\n        if (subscribeCount > 0) {\r\n          SignalingLog.info('Subscribed to topic', {\r\n            topic: this.topic,\r\n            brokerCount: subscribeCount\r\n          })\r\n          this.updateSignalingState('connected')\r\n        } else {\r\n          SignalingLog.warn('MQTT subscription failed on all brokers')\r\n          this.mqtt.disconnect()\r\n          this.mqtt = null\r\n        }\r\n\r\n      } catch (err) {\r\n        SignalingLog.error('MQTT connection failed', { error: String(err) })\r\n        this.onError(err as Error, 'mqtt-connection')\r\n        if (this.mqtt) {\r\n          this.mqtt.disconnect()\r\n          this.mqtt = null\r\n        }\r\n      }\r\n\r\n      if (!this.mqtt?.isConnected()) {\r\n        // NOTE: BroadcastChannel CANNOT replace MQTT for remote communication.\r\n        // BroadcastChannel only works within the same browser on the same machine (same origin).\r\n        // This state means we failed to connect to any MQTT brokers, so:\r\n        // - Local testing (same machine) will still work via BroadcastChannel\r\n        // - Remote peers on different machines will NOT be able to connect\r\n        SignalingLog.warn('MQTT unavailable - remote connections will NOT work. Only same-device testing via BroadcastChannel is possible.')\r\n        // Still set to 'connected' so the user can see the room and wait for MQTT to recover\r\n        this.updateSignalingState('connected')\r\n\r\n        // Log additional info for debugging\r\n        SignalingLog.info('BroadcastChannel is active for same-device communication only', {\r\n          note: 'To connect with remote peers, ensure at least one MQTT broker is reachable'\r\n        })\r\n      }\r\n\r\n      // Start announcing presence\r\n      setTimeout(() => {\r\n        if (this.sessionId === currentSession) {\r\n          this.broadcastAnnounce()\r\n        }\r\n      }, 300)\r\n      this.startAnnounceInterval()\r\n\r\n      SignalingLog.info('Successfully joined room', {\r\n        roomId,\r\n        mqttConnected: this.mqtt?.isConnected() || false,\r\n        mqttBrokerCount: this.mqtt?.getConnectedCount() || 0,\r\n        sessionId: currentSession\r\n      })\r\n    } finally {\r\n      this.isJoining = false\r\n    }\r\n  }\r\n\r\n  private broadcastAnnounce() {\r\n    // Debounce announce messages to prevent flooding\r\n    if (this.announceDebounceTimer) {\r\n      clearTimeout(this.announceDebounceTimer)\r\n    }\r\n\r\n    this.announceDebounceTimer = setTimeout(() => {\r\n      const msg: SignalMessage = {\r\n        v: 1,\r\n        type: 'announce',\r\n        from: selfId,\r\n        userName: this.userName,\r\n        platform: this.localPlatform,\r\n        ts: Date.now(),\r\n        sessionId: this.sessionId,\r\n        msgId: generateMessageId()\r\n      }\r\n\r\n      SignalingLog.debug('Broadcasting announce', { selfId, peerCount: this.peers.size })\r\n      this.broadcast(msg)\r\n      this.announceDebounceTimer = null\r\n    }, ANNOUNCE_DEBOUNCE)\r\n  }\r\n\r\n  // Only count peers that have a healthy connection\r\n  private getHealthyPeerCount(): number {\r\n    let count = 0\r\n    this.peers.forEach((peer) => {\r\n      const state = peer.pc.connectionState\r\n      if (state === 'connected' || state === 'connecting') {\r\n        count++\r\n      }\r\n    })\r\n    return count\r\n  }\r\n\r\n  private startAnnounceInterval() {\r\n    this.stopAnnounceInterval()\r\n\r\n    this.announceInterval = setInterval(() => {\r\n      const elapsed = Date.now() - this.announceStartTime\r\n\r\n      if (elapsed > ANNOUNCE_DURATION && this.getHealthyPeerCount() > 0) {\r\n        this.stopAnnounceInterval()\r\n        return\r\n      }\r\n\r\n      if (this.getHealthyPeerCount() === 0) {\r\n        SignalingLog.debug('Re-announcing', { elapsed: Math.round(elapsed / 1000) + 's' })\r\n        this.broadcastAnnounce()\r\n      }\r\n    }, ANNOUNCE_INTERVAL)\r\n  }\r\n\r\n  private stopAnnounceInterval() {\r\n    if (this.announceInterval) {\r\n      clearInterval(this.announceInterval)\r\n      this.announceInterval = null\r\n    }\r\n    if (this.announceDebounceTimer) {\r\n      clearTimeout(this.announceDebounceTimer)\r\n      this.announceDebounceTimer = null\r\n    }\r\n  }\r\n\r\n  private broadcast(message: SignalMessage) {\r\n    // Ensure message has an ID for deduplication\r\n    if (!message.msgId) {\r\n      message.msgId = generateMessageId()\r\n    }\r\n\r\n    const jsonStr = JSON.stringify(message)\r\n    const sentVia: string[] = []\r\n\r\n    // Publish to ALL connected MQTT brokers\r\n    if (this.mqtt?.isConnected()) {\r\n      const publishCount = this.mqtt.publish(this.topic, jsonStr)\r\n      if (publishCount > 0) {\r\n        sentVia.push(`MQTT(${publishCount} brokers)`)\r\n      }\r\n    }\r\n\r\n    // Also send via BroadcastChannel for same-device\r\n    if (this.broadcastChannel) {\r\n      try {\r\n        this.broadcastChannel.postMessage(message)\r\n        sentVia.push('BroadcastChannel')\r\n      } catch { /* BroadcastChannel may be closed */ }\r\n    }\r\n\r\n    if (message.type !== 'ping' && message.type !== 'pong' && message.type !== 'mute-status') {\r\n      SignalingLog.debug('Message broadcast', { type: message.type, to: message.to || 'all', sentVia, size: jsonStr.length })\r\n    }\r\n  }\r\n\r\n  private sendToPeer(peerId: string, message: SignalMessage) {\r\n    message.to = peerId\r\n    message.sessionId = this.sessionId\r\n    if (!message.msgId) {\r\n      message.msgId = generateMessageId()\r\n    }\r\n    this.broadcast(message)\r\n  }\r\n\r\n  private handleSignalingMessage(message: SignalMessage) {\r\n    // Filter out own messages\r\n    if (message.from === selfId) {\r\n      return\r\n    }\r\n\r\n    // Filter out messages for other peers\r\n    if (message.to && message.to !== selfId) {\r\n      return\r\n    }\r\n\r\n    if (message.type !== 'ping' && message.type !== 'pong' && message.type !== 'mute-status') {\r\n      SignalingLog.info('Received signaling message', { type: message.type, from: message.from, userName: message.userName })\r\n    }\r\n\r\n    switch (message.type) {\r\n      case 'announce':\r\n        this.handleAnnounce(message.from, message.userName || 'Unknown', message.platform || 'win')\r\n        break\r\n      case 'offer':\r\n        this.handleOffer(message.from, message.data, message.userName || 'Unknown', message.platform || 'win')\r\n        break\r\n      case 'answer':\r\n        this.handleAnswer(message.from, message.data)\r\n        break\r\n      case 'ice-candidate':\r\n        this.handleIceCandidate(message.from, message.data)\r\n        break\r\n      case 'leave':\r\n        this.handlePeerLeave(message.from)\r\n        break\r\n      case 'ping':\r\n        this.sendToPeer(message.from, { v: 1, type: 'pong', from: selfId })\r\n        break\r\n      case 'mute-status':\r\n        this.handleMuteStatus(message.from, message.data)\r\n        break\r\n    }\r\n  }\r\n\r\n  private handleMuteStatus(peerId: string, data: { micMuted?: boolean; speakerMuted?: boolean }) {\r\n    const peer = this.peers.get(peerId)\r\n    if (peer) {\r\n      peer.muteStatus = {\r\n        micMuted: data.micMuted ?? peer.muteStatus.micMuted,\r\n        speakerMuted: data.speakerMuted ?? peer.muteStatus.speakerMuted\r\n      }\r\n      SignalingLog.debug('Peer mute status changed', { peerId, ...peer.muteStatus })\r\n      this.onPeerMuteChange(peerId, peer.muteStatus)\r\n    }\r\n  }\r\n\r\n  private async handleAnnounce(peerId: string, userName: string, platform: 'win' | 'mac' | 'linux') {\r\n    PeerLog.info('Received announce', { peerId, userName, platform })\r\n\r\n    const existingPeer = this.peers.get(peerId)\r\n    if (existingPeer) {\r\n      const state = existingPeer.pc.connectionState\r\n\r\n      PeerLog.info('Check existing peer', { peerId, state, isConnected: existingPeer.isConnected })\r\n\r\n      if (state !== 'closed' && state !== 'failed' &&\r\n        !(state === 'disconnected' && !existingPeer.iceRestartInProgress)) {\r\n        PeerLog.info('Ignoring duplicate announce - connection is alive', { peerId, state })\r\n        return\r\n      }\r\n\r\n      PeerLog.info('Cleaning up dead peer', { peerId, state })\r\n      try {\r\n        existingPeer.pc.close()\r\n      } catch { /* ignore close errors */ }\r\n      this.peers.delete(peerId)\r\n    }\r\n\r\n    if (selfId > peerId) {\r\n      PeerLog.info('Initiating connection', { selfId, peerId })\r\n      await this.createOffer(peerId, userName, platform)\r\n    } else {\r\n      PeerLog.info('Waiting for peer to initiate', { selfId, peerId })\r\n      this.sendToPeer(peerId, { v: 1, type: 'announce', from: selfId, userName: this.userName, platform: this.localPlatform, ts: Date.now() })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Configure Opus codec for optimal audio quality\r\n   */\r\n  private configureOpusCodec(sdp: string): string {\r\n    return sdp.replace(\r\n      /(a=fmtp:\\d+ .*)/g,\r\n      '$1;maxaveragebitrate=60000;stereo=0;useinbandfec=1'\r\n    )\r\n  }\r\n\r\n  private async createOffer(peerId: string, userName: string, platform: 'win' | 'mac' | 'linux') {\r\n    PeerLog.info('Creating offer', { peerId })\r\n\r\n    try {\r\n      const pc = this.createPeerConnection(peerId, userName, platform)\r\n      const offer = await pc.createOffer()\r\n\r\n      const configuredSdp = this.configureOpusCodec(offer.sdp || '')\r\n      const configuredOffer: RTCSessionDescriptionInit = {\r\n        type: offer.type,\r\n        sdp: configuredSdp\r\n      }\r\n\r\n      await pc.setLocalDescription(configuredOffer)\r\n\r\n      this.sendToPeer(peerId, {\r\n        v: 1,\r\n        type: 'offer',\r\n        from: selfId,\r\n        data: { type: configuredOffer.type, sdp: configuredOffer.sdp },\r\n        userName: this.userName,\r\n        platform: this.localPlatform\r\n      })\r\n\r\n      PeerLog.info('Offer sent (trickle ICE, Opus configured)', { peerId })\r\n    } catch (err) {\r\n      PeerLog.error('Failed to create offer', { peerId, error: String(err) })\r\n      this.peers.delete(peerId)\r\n    }\r\n  }\r\n\r\n  private async handleOffer(peerId: string, offer: RTCSessionDescriptionInit, userName: string, platform: 'win' | 'mac' | 'linux') {\r\n    PeerLog.info('Received offer', { peerId })\r\n\r\n    const existing = this.peers.get(peerId)\r\n    if (existing) {\r\n      try {\r\n        existing.pc.close()\r\n      } catch { /* ignore close errors */ }\r\n      this.peers.delete(peerId)\r\n    }\r\n\r\n    try {\r\n      const pc = this.createPeerConnection(peerId, userName, platform)\r\n      await pc.setRemoteDescription(new RTCSessionDescription(offer))\r\n\r\n      const pending = this.pendingCandidates.get(peerId) || []\r\n      for (const c of pending) {\r\n        try {\r\n          await pc.addIceCandidate(new RTCIceCandidate(c))\r\n        } catch {\r\n          PeerLog.warn('Failed to add pending ICE candidate', { peerId })\r\n        }\r\n      }\r\n      this.pendingCandidates.delete(peerId)\r\n\r\n      const answer = await pc.createAnswer()\r\n      await pc.setLocalDescription(answer)\r\n\r\n      this.sendToPeer(peerId, {\r\n        v: 1,\r\n        type: 'answer',\r\n        from: selfId,\r\n        data: { type: answer.type, sdp: answer.sdp }\r\n      })\r\n      PeerLog.info('Answer sent (trickle ICE)', { peerId })\r\n    } catch (err) {\r\n      PeerLog.error('Failed to handle offer', { peerId, error: String(err) })\r\n      this.peers.delete(peerId)\r\n    }\r\n  }\r\n\r\n  private async handleAnswer(peerId: string, answer: RTCSessionDescriptionInit) {\r\n    PeerLog.info('Received answer', { peerId })\r\n\r\n    const peer = this.peers.get(peerId)\r\n    if (!peer) return\r\n\r\n    try {\r\n      await peer.pc.setRemoteDescription(new RTCSessionDescription(answer))\r\n\r\n      const pending = this.pendingCandidates.get(peerId) || []\r\n      for (const c of pending) {\r\n        try {\r\n          await peer.pc.addIceCandidate(new RTCIceCandidate(c))\r\n        } catch {\r\n          PeerLog.warn('Failed to add pending ICE candidate', { peerId })\r\n        }\r\n      }\r\n      this.pendingCandidates.delete(peerId)\r\n    } catch (err) {\r\n      PeerLog.error('Failed to handle answer', { peerId, error: String(err) })\r\n    }\r\n  }\r\n\r\n  private async handleIceCandidate(peerId: string, candidate: RTCIceCandidateInit) {\r\n    const peer = this.peers.get(peerId)\r\n\r\n    if (!peer || !peer.pc.remoteDescription) {\r\n      if (!this.pendingCandidates.has(peerId)) {\r\n        this.pendingCandidates.set(peerId, [])\r\n      }\r\n      this.pendingCandidates.get(peerId)!.push(candidate)\r\n      PeerLog.debug('Queued ICE candidate', { peerId, queueSize: this.pendingCandidates.get(peerId)!.length })\r\n      return\r\n    }\r\n\r\n    try {\r\n      await peer.pc.addIceCandidate(new RTCIceCandidate(candidate))\r\n      PeerLog.debug('Added ICE candidate', { peerId })\r\n    } catch (err) {\r\n      PeerLog.error('Failed to add ICE candidate', { peerId, error: String(err) })\r\n    }\r\n  }\r\n\r\n  private handlePeerLeave(peerId: string) {\r\n    const peer = this.peers.get(peerId)\r\n    if (peer) {\r\n      PeerLog.info('Peer leaving (via leave message)', { peerId })\r\n      this.cleanupPeer(peerId)\r\n    }\r\n  }\r\n\r\n  private createPeerConnection(peerId: string, userName: string, platform: 'win' | 'mac' | 'linux'): RTCPeerConnection {\r\n    PeerLog.info('Creating RTCPeerConnection', { peerId, userName, platform })\r\n\r\n    const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS })\r\n\r\n    const peerConn: PeerConnection = {\r\n      pc, stream: null, userName, platform,\r\n      connectionStartTime: Date.now(),\r\n      isConnected: false,\r\n      muteStatus: { micMuted: false, speakerMuted: false },\r\n      iceRestartAttempts: 0,\r\n      iceRestartInProgress: false,\r\n      disconnectTimer: null,\r\n      reconnectTimer: null\r\n    }\r\n\r\n    this.peers.set(peerId, peerConn)\r\n\r\n    if (this.localStream) {\r\n      this.localStream.getTracks().forEach(track => {\r\n        pc.addTrack(track, this.localStream!)\r\n      })\r\n    }\r\n\r\n    pc.onicecandidate = (event) => {\r\n      if (event.candidate) {\r\n        PeerLog.debug('Sending ICE candidate', { peerId, type: event.candidate.type })\r\n        this.sendToPeer(peerId, {\r\n          v: 1,\r\n          type: 'ice-candidate',\r\n          from: selfId,\r\n          data: event.candidate.toJSON()\r\n        })\r\n      }\r\n    }\r\n\r\n    pc.oniceconnectionstatechange = () => {\r\n      const iceState = pc.iceConnectionState\r\n      const currentPeer = this.peers.get(peerId)\r\n\r\n      PeerLog.info('ICE state', { peerId, state: iceState })\r\n\r\n      if (iceState === 'connected' || iceState === 'completed') {\r\n        // Clear any pending timers on successful connection\r\n        if (currentPeer) {\r\n          if (currentPeer.disconnectTimer) {\r\n            clearTimeout(currentPeer.disconnectTimer)\r\n            currentPeer.disconnectTimer = null\r\n          }\r\n          if (currentPeer.reconnectTimer) {\r\n            clearTimeout(currentPeer.reconnectTimer)\r\n            currentPeer.reconnectTimer = null\r\n          }\r\n          currentPeer.iceRestartInProgress = false\r\n          currentPeer.iceRestartAttempts = 0  // Reset attempts on success\r\n        }\r\n      } else if (iceState === 'failed') {\r\n        PeerLog.warn('ICE connection failed, attempting restart', { peerId })\r\n        // Don't call handlePeerLeave yet - try to restart first\r\n        this.attemptIceRestart(peerId)\r\n      } else if (iceState === 'disconnected') {\r\n        PeerLog.warn('ICE connection disconnected, scheduling reconnect attempt', { peerId })\r\n\r\n        // Clear any existing timer\r\n        if (currentPeer?.disconnectTimer) {\r\n          clearTimeout(currentPeer.disconnectTimer)\r\n        }\r\n\r\n        // Set a grace period timer - don't immediately restart, as disconnected can be transient\r\n        if (currentPeer) {\r\n          currentPeer.disconnectTimer = setTimeout(() => {\r\n            const peer = this.peers.get(peerId)\r\n            if (peer && peer.pc.iceConnectionState === 'disconnected') {\r\n              PeerLog.info('ICE still disconnected after grace period, attempting restart', { peerId })\r\n              this.attemptIceRestart(peerId)\r\n            }\r\n          }, ICE_DISCONNECT_GRACE_PERIOD)\r\n        }\r\n      }\r\n    }\r\n\r\n    pc.onconnectionstatechange = () => {\r\n      const state = pc.connectionState\r\n      const currentPeer = this.peers.get(peerId)\r\n\r\n      PeerLog.info('Connection state', { peerId, state })\r\n\r\n      if (state === 'connected') {\r\n        if (currentPeer) {\r\n          currentPeer.isConnected = true\r\n          currentPeer.iceRestartInProgress = false\r\n\r\n          // Clear any pending timers\r\n          if (currentPeer.disconnectTimer) {\r\n            clearTimeout(currentPeer.disconnectTimer)\r\n            currentPeer.disconnectTimer = null\r\n          }\r\n          if (currentPeer.reconnectTimer) {\r\n            clearTimeout(currentPeer.reconnectTimer)\r\n            currentPeer.reconnectTimer = null\r\n          }\r\n        }\r\n        this.stopAnnounceInterval()\r\n        this.onPeerJoin(peerId, userName, platform)\r\n\r\n        // Send our current mute status to the newly connected peer\r\n        setTimeout(() => {\r\n          this.sendToPeer(peerId, {\r\n            v: 1,\r\n            type: 'mute-status',\r\n            from: selfId,\r\n            data: this.localMuteStatus\r\n          })\r\n        }, 500)\r\n      } else if (state === 'disconnected') {\r\n        // DON'T immediately remove peer on disconnect - ICE restart might save it\r\n        PeerLog.warn('Connection disconnected, ICE restart may recover', { peerId })\r\n        // The ICE state handler will manage restart attempts\r\n      } else if (state === 'failed') {\r\n        // Connection failed - if we're not already trying to restart, give up\r\n        if (currentPeer && !currentPeer.iceRestartInProgress) {\r\n          PeerLog.warn('Connection failed and no restart in progress, removing peer', { peerId })\r\n          this.cleanupPeer(peerId)\r\n        }\r\n      } else if (state === 'closed') {\r\n        // Connection was explicitly closed\r\n        if (currentPeer?.isConnected) {\r\n          currentPeer.isConnected = false\r\n          this.cleanupPeer(peerId)\r\n        } else {\r\n          this.peers.delete(peerId)\r\n        }\r\n      }\r\n    }\r\n\r\n    pc.ontrack = (event) => {\r\n      PeerLog.info('Received remote track', {\r\n        peerId,\r\n        kind: event.track.kind,\r\n        trackId: event.track.id,\r\n        streamCount: event.streams?.length || 0\r\n      })\r\n\r\n      let remoteStream: MediaStream\r\n      if (event.streams && event.streams[0]) {\r\n        remoteStream = event.streams[0]\r\n      } else {\r\n        PeerLog.info('Creating MediaStream from track (no stream in event)', { peerId })\r\n        remoteStream = new MediaStream([event.track])\r\n      }\r\n\r\n      peerConn.stream = remoteStream\r\n\r\n      PeerLog.info('Calling onRemoteStream callback', {\r\n        peerId,\r\n        streamId: remoteStream.id,\r\n        trackCount: remoteStream.getTracks().length,\r\n        audioTracks: remoteStream.getAudioTracks().length\r\n      })\r\n      this.onRemoteStream(peerId, remoteStream)\r\n    }\r\n\r\n    return pc\r\n  }\r\n\r\n  /**\r\n   * Clean up a peer connection and notify listeners\r\n   * This is the single point of truth for removing a peer\r\n   */\r\n  private cleanupPeer(peerId: string) {\r\n    const peer = this.peers.get(peerId)\r\n    if (!peer) return\r\n\r\n    PeerLog.info('Cleaning up peer', { peerId, userName: peer.userName })\r\n\r\n    // Clear any pending timers\r\n    if (peer.disconnectTimer) {\r\n      clearTimeout(peer.disconnectTimer)\r\n      peer.disconnectTimer = null\r\n    }\r\n    if (peer.reconnectTimer) {\r\n      clearTimeout(peer.reconnectTimer)\r\n      peer.reconnectTimer = null\r\n    }\r\n\r\n    // Close the peer connection\r\n    try {\r\n      peer.pc.close()\r\n    } catch (err) {\r\n      PeerLog.warn('Error closing peer connection during cleanup', { peerId, error: String(err) })\r\n    }\r\n\r\n    // Remove from maps\r\n    this.peers.delete(peerId)\r\n    this.pendingCandidates.delete(peerId)\r\n\r\n    // Notify listeners\r\n    this.onPeerLeave(peerId, peer.userName, peer.platform)\r\n\r\n    // If no healthy peers remain, start looking for peers again\r\n    if (this.getHealthyPeerCount() === 0 && this.roomId) {\r\n      SignalingLog.info('No healthy peers, restarting peer discovery')\r\n      this.announceStartTime = Date.now()\r\n      this.broadcastAnnounce()\r\n      this.startAnnounceInterval()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempt ICE restart for a peer connection\r\n   * This is called when ICE connection becomes disconnected or failed\r\n   */\r\n  private async attemptIceRestart(peerId: string) {\r\n    const peer = this.peers.get(peerId)\r\n    if (!peer) {\r\n      PeerLog.warn('Cannot restart ICE - peer not found', { peerId })\r\n      return\r\n    }\r\n\r\n    // Prevent concurrent restart attempts\r\n    if (peer.iceRestartInProgress) {\r\n      PeerLog.debug('ICE restart already in progress', { peerId })\r\n      return\r\n    }\r\n\r\n    if (peer.iceRestartAttempts >= MAX_ICE_RESTART_ATTEMPTS) {\r\n      PeerLog.warn('Max ICE restart attempts reached, giving up', { peerId, attempts: peer.iceRestartAttempts })\r\n      this.cleanupPeer(peerId)\r\n      return\r\n    }\r\n\r\n    peer.iceRestartAttempts++\r\n    peer.iceRestartInProgress = true\r\n\r\n    PeerLog.info('Attempting ICE restart', {\r\n      peerId,\r\n      attempt: peer.iceRestartAttempts,\r\n      maxAttempts: MAX_ICE_RESTART_ATTEMPTS,\r\n      currentIceState: peer.pc.iceConnectionState,\r\n      currentConnState: peer.pc.connectionState\r\n    })\r\n\r\n    // Set a timeout for the restart attempt\r\n    if (peer.reconnectTimer) {\r\n      clearTimeout(peer.reconnectTimer)\r\n    }\r\n\r\n    peer.reconnectTimer = setTimeout(() => {\r\n      const currentPeer = this.peers.get(peerId)\r\n      if (currentPeer && currentPeer.iceRestartInProgress) {\r\n        PeerLog.warn('ICE restart timed out', { peerId, attempt: currentPeer.iceRestartAttempts })\r\n        currentPeer.iceRestartInProgress = false\r\n\r\n        // Try again if we have attempts left\r\n        if (currentPeer.iceRestartAttempts < MAX_ICE_RESTART_ATTEMPTS) {\r\n          this.attemptIceRestart(peerId)\r\n        } else {\r\n          this.cleanupPeer(peerId)\r\n        }\r\n      }\r\n    }, ICE_FAILED_TIMEOUT)\r\n\r\n    try {\r\n      // Check if the connection is still usable\r\n      if (peer.pc.signalingState === 'closed') {\r\n        PeerLog.warn('Cannot restart ICE - peer connection is closed', { peerId })\r\n        peer.iceRestartInProgress = false\r\n        this.cleanupPeer(peerId)\r\n        return\r\n      }\r\n\r\n      const offer = await peer.pc.createOffer({ iceRestart: true })\r\n      const configuredSdp = this.configureOpusCodec(offer.sdp || '')\r\n\r\n      const configuredOffer: RTCSessionDescriptionInit = {\r\n        type: offer.type,\r\n        sdp: configuredSdp\r\n      }\r\n\r\n      await peer.pc.setLocalDescription(configuredOffer)\r\n\r\n      this.sendToPeer(peerId, {\r\n        v: 1,\r\n        type: 'offer',\r\n        from: selfId,\r\n        data: { type: configuredOffer.type, sdp: configuredOffer.sdp },\r\n        userName: this.userName\r\n      })\r\n\r\n      PeerLog.info('ICE restart offer sent', { peerId, attempt: peer.iceRestartAttempts })\r\n\r\n    } catch (err) {\r\n      PeerLog.error('ICE restart failed to create offer', { peerId, error: String(err) })\r\n      peer.iceRestartInProgress = false\r\n\r\n      // If this was the last attempt, clean up\r\n      if (peer.iceRestartAttempts >= MAX_ICE_RESTART_ATTEMPTS) {\r\n        this.cleanupPeer(peerId)\r\n      } else {\r\n        // Schedule another attempt with exponential backoff\r\n        const delay = ICE_RESTART_DELAY * Math.pow(2, peer.iceRestartAttempts - 1)\r\n        PeerLog.info('Scheduling next ICE restart attempt', { peerId, delayMs: delay })\r\n        setTimeout(() => this.attemptIceRestart(peerId), delay)\r\n      }\r\n    }\r\n  }\r\n\r\n  leaveRoom() {\r\n    // Prevent leaving if not in a room\r\n    if (!this.roomId) {\r\n      SignalingLog.debug('Already left room, skipping')\r\n      return\r\n    }\r\n\r\n    // Prevent concurrent leave operations\r\n    if (this.isLeaving) {\r\n      SignalingLog.warn('Leave already in progress, ignoring')\r\n      return\r\n    }\r\n\r\n    this.isLeaving = true\r\n\r\n    try {\r\n      SignalingLog.info('Leaving room', { roomId: this.roomId, sessionId: this.sessionId })\r\n\r\n      this.stopAnnounceInterval()\r\n\r\n      // Send leave message only if connected\r\n      if (this.mqtt?.isConnected()) {\r\n        this.broadcast({ v: 1, type: 'leave', from: selfId, sessionId: this.sessionId })\r\n      }\r\n\r\n      // Close all peer connections with error handling and clear timers\r\n      this.peers.forEach((peer, peerId) => {\r\n        // Clear any pending timers\r\n        if (peer.disconnectTimer) {\r\n          clearTimeout(peer.disconnectTimer)\r\n        }\r\n        if (peer.reconnectTimer) {\r\n          clearTimeout(peer.reconnectTimer)\r\n        }\r\n\r\n        try {\r\n          peer.pc.close()\r\n        } catch (err) {\r\n          PeerLog.warn('Error closing peer connection', { peerId, error: String(err) })\r\n        }\r\n      })\r\n      this.peers.clear()\r\n      this.pendingCandidates.clear()\r\n\r\n      // Disconnect all MQTT brokers\r\n      if (this.mqtt) {\r\n        this.mqtt.disconnect()\r\n        this.mqtt = null\r\n      }\r\n\r\n      // Close BroadcastChannel\r\n      if (this.broadcastChannel) {\r\n        try {\r\n          this.broadcastChannel.close()\r\n        } catch { /* ignored */ }\r\n        this.broadcastChannel = null\r\n      }\r\n\r\n      this.roomId = null\r\n      this.topic = ''\r\n      this.localStream = null\r\n      this.localMuteStatus = { micMuted: false, speakerMuted: false }\r\n      this.updateSignalingState('idle')\r\n\r\n      SignalingLog.info('Left room successfully')\r\n    } finally {\r\n      this.isLeaving = false\r\n    }\r\n  }\r\n\r\n  getPeers(): Map<string, { userName: string; stream: MediaStream | null; muteStatus: MuteStatus }> {\r\n    const result = new Map()\r\n    this.peers.forEach((peer, id) => result.set(id, {\r\n      userName: peer.userName,\r\n      stream: peer.stream,\r\n      muteStatus: peer.muteStatus\r\n    }))\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * Replace audio track in all peer connections (for device switching)\r\n   * This is the critical method for microphone switching while in a call\r\n   */\r\n  replaceTrack(newTrack: MediaStreamTrack) {\r\n    if (!newTrack) {\r\n      PeerLog.error('replaceTrack called with null/undefined track')\r\n      return\r\n    }\r\n\r\n    PeerLog.info('Replacing audio track in all peers', {\r\n      trackId: newTrack.id,\r\n      label: newTrack.label,\r\n      peerCount: this.peers.size,\r\n      trackEnabled: newTrack.enabled,\r\n      trackReadyState: newTrack.readyState\r\n    })\r\n\r\n    if (this.peers.size === 0) {\r\n      PeerLog.warn('No peers to replace track for')\r\n      return\r\n    }\r\n\r\n    this.peers.forEach((peer, peerId) => {\r\n      const senders = peer.pc.getSenders()\r\n      PeerLog.debug('Peer senders', {\r\n        peerId,\r\n        senderCount: senders.length,\r\n        senderTracks: senders.map(s => ({\r\n          kind: s.track?.kind,\r\n          id: s.track?.id,\r\n          readyState: s.track?.readyState\r\n        }))\r\n      })\r\n\r\n      // Find audio sender - check for kind 'audio' or sender with null track (empty slot)\r\n      let audioSender = senders.find(s => s.track?.kind === 'audio')\r\n\r\n      // If no audio sender with track, look for one that could accept an audio track\r\n      if (!audioSender) {\r\n        // Look for a sender that was created for audio but has no track\r\n        audioSender = senders.find(s => {\r\n          // Senders created for audio transceivers will have appropriate capabilities\r\n          const params = s.getParameters()\r\n          return params.codecs?.some(c => c.mimeType.toLowerCase().includes('audio'))\r\n        })\r\n      }\r\n\r\n      if (audioSender) {\r\n        PeerLog.info('Replacing track for peer', {\r\n          peerId,\r\n          oldTrackId: audioSender.track?.id,\r\n          newTrackId: newTrack.id\r\n        })\r\n\r\n        audioSender.replaceTrack(newTrack)\r\n          .then(() => {\r\n            PeerLog.info('Track replaced successfully', { peerId, trackId: newTrack.id })\r\n          })\r\n          .catch((err) => {\r\n            PeerLog.error('Replace track failed', { peerId, error: String(err) })\r\n          })\r\n      } else {\r\n        PeerLog.warn('No audio sender found for peer, attempting to add track', { peerId })\r\n        // If no audio sender exists, add the track\r\n        try {\r\n          if (this.localStream) {\r\n            peer.pc.addTrack(newTrack, this.localStream)\r\n            PeerLog.info('Track added to peer (no existing sender)', { peerId })\r\n          }\r\n        } catch (err) {\r\n          PeerLog.error('Failed to add track to peer', { peerId, error: String(err) })\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Get connection quality statistics for all peers\r\n   * Returns RTT, packet loss, jitter, and bandwidth info\r\n   */\r\n  async getConnectionStats(): Promise<Map<string, ConnectionQuality>> {\r\n    const stats = new Map<string, ConnectionQuality>()\r\n\r\n    for (const [peerId, peer] of this.peers) {\r\n      try {\r\n        const rtcStats = await peer.pc.getStats()\r\n        let rtt = 0\r\n        let packetLoss = 0\r\n        let jitter = 0\r\n        let bytesReceived = 0\r\n        let bytesSent = 0\r\n\r\n        rtcStats.forEach((stat) => {\r\n          // Get round-trip time from candidate-pair stats\r\n          if (stat.type === 'candidate-pair' && stat.state === 'succeeded') {\r\n            rtt = stat.currentRoundTripTime ? stat.currentRoundTripTime * 1000 : 0\r\n          }\r\n\r\n          // Get packet loss and jitter from inbound-rtp stats (audio)\r\n          if (stat.type === 'inbound-rtp' && stat.kind === 'audio') {\r\n            if (stat.packetsReceived && stat.packetsLost) {\r\n              const totalPackets = stat.packetsReceived + stat.packetsLost\r\n              packetLoss = totalPackets > 0 ? (stat.packetsLost / totalPackets) * 100 : 0\r\n            }\r\n            jitter = stat.jitter ? stat.jitter * 1000 : 0\r\n            bytesReceived = stat.bytesReceived || 0\r\n          }\r\n\r\n          // Get bytes sent from outbound-rtp stats\r\n          if (stat.type === 'outbound-rtp' && stat.kind === 'audio') {\r\n            bytesSent = stat.bytesSent || 0\r\n          }\r\n        })\r\n\r\n        // Calculate quality score (0-100)\r\n        // Lower RTT, packet loss, and jitter = higher quality\r\n        let quality: 'excellent' | 'good' | 'fair' | 'poor' = 'excellent'\r\n        if (rtt > 300 || packetLoss > 5 || jitter > 50) {\r\n          quality = 'poor'\r\n        } else if (rtt > 200 || packetLoss > 2 || jitter > 30) {\r\n          quality = 'fair'\r\n        } else if (rtt > 100 || packetLoss > 1 || jitter > 15) {\r\n          quality = 'good'\r\n        }\r\n\r\n        stats.set(peerId, {\r\n          peerId,\r\n          rtt: Math.round(rtt),\r\n          packetLoss: Math.round(packetLoss * 100) / 100,\r\n          jitter: Math.round(jitter * 100) / 100,\r\n          bytesReceived,\r\n          bytesSent,\r\n          quality,\r\n          connectionState: peer.pc.connectionState\r\n        })\r\n      } catch (err) {\r\n        PeerLog.warn('Failed to get stats for peer', { peerId, error: String(err) })\r\n      }\r\n    }\r\n\r\n    return stats\r\n  }\r\n\r\n  getDebugInfo(): object {\r\n    return {\r\n      selfId,\r\n      roomId: this.roomId,\r\n      userName: this.userName,\r\n      topic: this.topic,\r\n      sessionId: this.sessionId,\r\n      signalingState: this.signalingState,\r\n      mqttConnected: this.mqtt?.isConnected() || false,\r\n      mqttSubscribed: this.mqtt?.isSubscribed() || false,\r\n      mqttBrokerCount: this.mqtt?.getConnectedCount() || 0,\r\n      mqttBrokerStatus: this.mqtt?.getConnectionStatus() || [],\r\n      mqttMessagesReceived: this.mqtt?.getTotalMessageCount() || 0,\r\n      mqttDedupCacheSize: this.mqtt?.getDeduplicatorSize() || 0,\r\n      peerCount: this.peers.size,\r\n      peers: Array.from(this.peers.keys()),\r\n      localMuteStatus: this.localMuteStatus,\r\n      isJoining: this.isJoining,\r\n      isLeaving: this.isLeaving\r\n    }\r\n  }\r\n}\r\n\r\nexport const peerManager = new SimplePeerManager()\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\signaling\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\utils\\Logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\utils\\i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\renderer\\utils\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\src\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\prj\\p2p_conference\\code\\tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
